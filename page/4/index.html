<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Jar-R</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Hi">
<meta property="og:type" content="website">
<meta property="og:title" content="Jar-R">
<meta property="og:url" content="http://Jarweb.com/page/4/index.html">
<meta property="og:site_name" content="Jar-R">
<meta property="og:description" content="Hi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jar-R">
<meta name="twitter:description" content="Hi">
  
    <link rel="alternative" href="/atom.xml" title="Jar-R" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">任先生在路上</a></h1>
		</hgroup>

		
		<p class="header-subtitle" style="margin-bottom:20px;">Good things are coming !</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger" style="display:none;"></div>
  		<h1 class="header-author js-mobile-header hide">任先生在路上</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">任先生在路上</h1>
			</hgroup>
			
			<p class="header-subtitle">Good things are coming !</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-express 中间件" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/03/express 中间件/" class="article-date">
  	<time datetime="2016-07-02T16:00:00.000Z" itemprop="datePublished">2016-07-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/express 中间件/">express 中间件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>express 中间件：</p>
<p>basicAuth()<br>基本的认证中间件，在req.user里添加用户名</p>
<p>用户名和密码的例子:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.basicAuth(&#39;username&#39;, &#39;password&#39;));</span><br></pre></td></tr></table></figure></p>
<p>校验回调:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.basicAuth(function(user, pass)&#123;&#10;  return &#39;tj&#39; == user &#38;&#38; &#39;wahoo&#39; == pass;&#10;&#125;));</span><br></pre></td></tr></table></figure></p>
<p>异步校验接受参数fn(err, user), 下面的例子req.user 将会作为user对象传递.<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(connect.basicAuth(function(user, pass, fn)&#123;&#10;  User.authenticate(&#123; user: user, pass: pass &#125;, fn);&#10;&#125;))</span><br></pre></td></tr></table></figure></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/express/">express</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/07/03/express 中间件/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-express app.js" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/01/express app.js/" class="article-date">
  	<time datetime="2016-06-30T16:00:00.000Z" itemprop="datePublished">2016-07-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/01/express app.js/">express app.js</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&#39;express&#39;)&#10;var path=require(&#39;path&#39;)&#10;&#10;&#10;var mongoose=require(&#39;mongoose&#39;)&#10;var dbUrl=&#39;mongodb://127.0.0.1/zbyou&#39;&#10;&#9;mongoose.connect(dbUrl)&#10;&#10;var session = require(&#39;express-session&#39;)&#10;var mongoStore=require(&#39;connect-mongo&#39;)(session)&#10;&#10;var serveStatic = require(&#39;serve-static&#39;)&#10;var bodyParser=require(&#39;body-parser&#39;)&#10;var cookieParser=require(&#39;cookie-parser&#39;)&#10;&#10;var port=process.env.PORT||3001&#10;var app=express()&#10;&#9;app.listen(port)&#10;&#10;&#60;!--more--&#62;&#10;app.use(bodyParser.json())&#10;app.use(bodyParser.urlencoded(&#123;extended:false&#125;))&#10;app.use(function(req, res, next) &#123;&#10;    res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)&#10;    res.setHeader(&#39;Access-Control-Allow-Methods&#39;, &#39;GET, POST&#39;)&#10;    res.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;X-Requested-With,content-type, Authorization&#39;);&#10;    next()&#10;&#125;)&#10;&#10;app.use(cookieParser())&#10;app.use(session(&#123;&#10;&#9;secret:&#39;zbyou&#39;,&#10;&#9;saveUninitialized: true,&#10;&#9;resave: false,&#10;&#9;store: new mongoStore(&#123;&#10;&#9;&#9;url:dbUrl,&#10;&#9;&#9;collection:&#39;sessions&#39;&#10;&#9;&#125;)&#10;&#125;))&#10;&#10;app.set(&#39;views&#39;, path.join(__dirname, &#39;../font-end/managem/views&#39;))//&#35774;&#32622;view&#30340;&#36335;&#24452; &#32534;&#35793;jade&#10;app.set(&#39;view engine&#39;, &#39;jade&#39;)&#10;&#10;app.use(serveStatic(path.join(__dirname,&#39;../&#39;)))//&#30456;&#23545;app.js&#26469;&#35828; &#35774;&#32622;&#38745;&#24577;&#36164;&#28304;&#30340;&#36335;&#21170;&#36215;&#28857;css jpg js&#31561;&#10;app.locals.moment=require(&#39;moment&#39;)&#10;&#10;require(&#39;./config/routes&#39;)(app)&#10;&#10;console.log(&#39;zbyou started on port &#39; + port)</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/express/">express</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-canvas图片处理运用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/27/canvas图片处理运用/" class="article-date">
  	<time datetime="2016-06-26T16:00:00.000Z" itemprop="datePublished">2016-06-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/27/canvas图片处理运用/">canvas图片处理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>canvas图片处理运用<br>对于canvas来说，主要是两个方法对图片处理比较重要，一个是通过html5 canvas的 getImageData 方法获取图片的像素信息，可以很方便的通过方法导入到把网络图片或者本地的图片导入至canvas中并获取图片的像素信息，可以修改像素信息后通过另外一个重要的方法putImageData导出处理后的图片。</p>
<p>1、获取canvas调用<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var c = document.createElement(&#39;canvas&#39;);&#10;context = c.getContext(&#39;2d&#39;);</span><br></pre></td></tr></table></figure></p>
<p>2、获取导入图像信息<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var hiddenImage = new Image();&#10;hiddenImage.src=&#22270;&#29255;&#22320;&#22336;&#10; context .drawImage(hiddenImage, 0, 0, width, height);&#10;   hiddenImage .onload=function()&#123;&#10;    context.putImageData(hiddenImage, 0, 0);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/canvas/">canvas</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/06/27/canvas图片处理运用/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Array" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/26/Array/" class="article-date">
  	<time datetime="2016-06-25T16:00:00.000Z" itemprop="datePublished">2016-06-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/26/Array/">array</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、Array 在内存中的堆栈模型</p>
<ol>
<li>Array 的获取</li>
</ol>
<p>Javascript 中如何产生 Array：</p>
<p>[element0, element1, …, elementN]</p>
<p>new Array(element0, element1, …, elementN)<br>new Array(arrayLength)</p>
<p>直接定义，或者通过构造函数创建一个 Array，当然也可以使用其他的手段：</p>
<p>“array”.split(“”);<br>“array”.match(/a|r/g);</p>
<p>等等，方式有很多。但是 Array 内部是个什么样的结构，恐怕很多人还不是很清楚。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/06/26/Array/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-电商接口" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/20/电商接口/" class="article-date">
  	<time datetime="2016-06-19T16:00:00.000Z" itemprop="datePublished">2016-06-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/20/电商接口/">一些接口</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>电商接口</p>
<p>京东获取单个商品价格接口：<br><a href="http://p.3.cn/prices/mgets?skuIds=J_商品ID&amp;type=1">http://p.3.cn/prices/mgets?skuIds=J_商品ID&amp;type=1</a><br>ps:商品ID这么获取:<a href="http://item.jd.com/954086.html">http://item.jd.com/954086.html</a></p>
<p>物流接口</p>
<p>快递接口：<br><a href="http://www.kuaidi100.com/query?type=快递公司代号&amp;postid=快递单号">http://www.kuaidi100.com/query?type=快递公司代号&amp;postid=快递单号</a><br>ps:快递公司编码:申通=”shentong” EMS=”ems” 顺丰=”shunfeng” 圆通=”yuantong” 中通=”zhongtong” 韵达=”yunda” 天天=”tiantian” 汇通=”huitongkuaidi” 全峰=”quanfengkuaidi” 德邦=”debangwuliu” 宅急送=”zhaijisong”</p>
<p>谷歌接口</p>
<p>FeedXml转json接口：<br><a href="http://ajax.googleapis.com/ajax/services/feed/load?q=Feed地址&amp;v=1.0">http://ajax.googleapis.com/ajax/services/feed/load?q=Feed地址&amp;v=1.0</a><br>备选参数:callback：&amp;callback=foo就会在json外面嵌套foo({})方便做jsonp使用。<br>备选参数:n：返回多少条记录。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/其他/">其他</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/06/20/电商接口/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-状态代码" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/18/状态代码/" class="article-date">
  	<time datetime="2016-06-17T16:00:00.000Z" itemprop="datePublished">2016-06-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/18/状态代码/">http状态码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>100    Continue    初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）</p>
<p>101    Switching Protocols    服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）</p>
<p>200    OK    一切正常，对GET和POST请求的应答文档跟在后面。</p>
<p>201    Created    服务器已经创建了文档，Location头给出了它的URL。</p>
<p>202    Accepted    已经接受请求，但处理尚未完成。</p>
<p>203    Non-Authoritative Information<br>文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝（HTTP 1.1新）。</p>
<p>204    No Content    没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/06/18/状态代码/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-居中" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/14/居中/" class="article-date">
  	<time datetime="2016-06-13T16:00:00.000Z" itemprop="datePublished">2016-06-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/14/居中/">css居中</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>水平居中<br>内联元素（inline or inline-*）居中?<br>你可以让他相对父级块级元素居中对齐<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.center-children &#123;&#10;  text-align: center;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>块级元素（block level）居中?<br>你可以通过设置margin-left和margin-right为auto让它居中（同时还要设置width，否则它就会承满整个容器，无法看出居中效果），如。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.center-me &#123;&#10;  margin: 0 auto;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/06/14/居中/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ajax2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/12/ajax2/" class="article-date">
  	<time datetime="2016-06-11T16:00:00.000Z" itemprop="datePublished">2016-06-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/12/ajax2/">ajax</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>(function(window){<br>    var initParam ={<br>        timeout:0,                                  //超时时间（单位：毫秒）<br>        type:””,                                    //请求类型（get、post…）<br>        url:””,                                     //请求接口<br>        data:””,                                    //请求参数（格式：json对象）  例子：{“name”:”gerry”,”age”:”88”}<br>        async:true,                                 //同|异步请求 （异步：true 同步：false）<br>        dataType:’’,                                //返回值处理（可拓展）   目前只实现：JSON<br>        isFormData:false,                              //是否为formData传输方式  ajax-level2方案  PS：因为使用formData数据传输，后台接口需要变化，数据取值将要在request的form对象中取值<br>        successEvent:function(data){},             //请求成功处理事件<br>        errorEvent:function(x,xx,xxx){},           //请求失败处理事件<br>        timeoutEvent:function(){},                 //请求超时处理事件<br>        requestHeader:{}                            //报文头设置（可自定义报文头）<br>    };<br>    var tool = {<br>        hasOwn: function(obj, key){<br>            return Object.prototype.hasOwnProperty.call(obj, key)<br>        },<br>        //类型判断<br>        is:(function checkType(){<br>            var is ={<br>                types : [“Array”, “Boolean”, “Date”, “Number”, “Object”, “RegExp”, “String”, “Window”, “HTMLDocument”]<br>            };<br>            for(var i = 0, c; c = is.types[i ++ ]; ){<br>                is[c] = (function(type){<br>                    return function(obj){<br>                        var temp = Object.prototype.toString.call(obj) == “[object “ + type + “]”;<br>                        if (temp) temp = obj;<br>                        return temp;<br>                    }<br>                })(c);<br>            };<br>            return is;<br>        })(),<br>        //获取对象的key<br>        keys: function(obj){<br>            if(Object.keys) return Object.keys(obj);</p>
<pre><code>        var keys = [];
        for(var key in obj){
            if(this.hasOwn(obj, key)) keys.push(key);
        };
        return keys
    },
    //each循环
    each:function(obj,callback){
        var keys = this.keys(obj);
        if (this.is.Array(obj)&amp;&amp;[].forEach){  //判断是否为数组且支持新特性
            obj.forEach(callback);
        }else{
            var i = 0, len = keys.length, key, item;
            while( i &lt; len ){
                key = keys[i++];
                item = obj[key];
                callback.call(obj, item, key);
            }
        }
    },
    //合并对象,将第二个合并到第一个对象上
    MergeObject:function(target,source){
        if(Object.assign){
            return Object.assign(target, source)
        }
        var targetKeys = this.keys(target),
            sourceKeys = this.keys(source),
            i = 0
        var len = sourceKeys.length;
        while( i &lt; len ){
            var key = sourceKeys[i++]
            target[key] = source[key];
        }
        return target;
    },
    //创建xhr对象
    createXhrObject:function(){
        var xhr;
        try{
            // IE7 已经有了XMLHttpRequest对象
            XMLHttpRequest?(xhr= new XMLHttpRequest()):(xhr= new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;));
        }catch (e){
            throw new Error(&apos;ajax:Could not create an XHR object.&apos;)
        };
        return xhr;
    },
    //ajax参数处理，可拓展
    dealWithParam:function(ajaxSetting,that,xhr){
        switch (ajaxSetting.type.toUpperCase()) {
            case &quot;GET&quot;:
                var getParam = &quot;?&quot;;
                tool.each(ajaxSetting.data,function(item,index){
                    getParam +=(encodeURI(index)+&quot;=&quot;+encodeURI(item)+&quot;&amp;&quot;)
                });
                //处理最后一位&quot;&amp;&quot;符号，其实不处理也没事，强迫症犯了，尴尬
                getParam =getParam.substr(0,getParam.length-1);
                //打开请求
                xhr.open(ajaxSetting.type.toUpperCase(), ajaxSetting.url+=getParam, ajaxSetting.async);
                break;
            case &quot;POST&quot;:
                //打开请求
                xhr.open(ajaxSetting.type.toUpperCase(), ajaxSetting.url, ajaxSetting.async);
                xhr.setRequestHeader(&quot;Accept&quot;,&quot;*/*&quot;);   //解决火狐浏览器默认要求后台发送xml类型返回值
                /*
                 *  1、 判断浏览器是否支持level2的属性
                 *       a、 支持。判断用户配置中是否设定使用formdata传输数据
                 *       b、 不支持。默认使用level1的传统发过誓传输数据
                 * */
                that.postParam = undefined;
                if(!(window.FormData &amp;&amp; ajaxSetting.isFormData)){
                    xhr.setRequestHeader(&quot;content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
                    var postParam =&quot;&quot;;
                    tool.each(ajaxSetting.data,function(item,index){
                        postParam +=(index+&quot;=&quot;+item+&quot;&amp;&quot;)
                    });
                    //处理最后一位&quot;&amp;&quot;符号，其实不处理也没事，强迫症犯了，尴尬
                    postParam =postParam.substr(0,postParam.length-1);
                    that.postParam = postParam;
                }
                break;
        };
        return xhr;
    },
    //判断IE版本
    // 如果不是IE，返回 true
    // 若是IE，返回IE版本号
    getIEVersion:function(){
        return function() {
            // 能进到这里来，说明一定是IE
            if (window.VBArray) {
                // 取出IE的版本
                var mode = document.documentMode
                // IE6、IE7 不支持documentMode，那就使用XMLHttpRequest，支持的就是IE7，否则就是IE6
                // 至于支持documentMode的IE，则直接return
                return mode ? mode : window.XMLHttpRequest ? 7 : 6
            } else {
                return NaN
            }
        }()
    },
    //切割大文件
    cutFile:function(file,cutSize){
        var count = file.size / cutSize | 0 ,fileArr = [];
        for (var i= 0; i&lt; count ; i++){
            fileArr.push({
                name:file.name+&quot;.part&quot;+(i+1),
                file:file.slice( cutSize * i , cutSize * ( i + 1 ))
            });
        };
        fileArr.push({
            name:file.name+&quot;.part&quot;+(count+1),
            file:file.slice(cutSize*count,file.size)
        });
        return fileArr;
    },
    //如果浏览器不支持Promise特性，将用简易的promise代替(IE11-都不支持ES6 Promise)
    createPromise:function(){
        var newPromise = function(fn){
            var promise = this;
            //状态机的状态
            var PROMISESTATE = {
                PENDING : 0 ,
                FULFILLED : 1 ,
                REJECTED : 2
            };
            //存储当前变量的回调函数和标记对象为promise
            promise._fullCalll =[],promise._rejCall = [];promise._name = &quot;promise&quot;;
            //执行过程中的状态变化(初始化状态为默认状态)
            var _state =  PROMISESTATE.PENDING;
            //回调函数的参数
            var _value = undefined;

            //状态变更
            function setState(stateT,valueT){
                var promise = this;
                _state = stateT;
                _value = valueT;
                handleFun.call(promise);  //传递作用域，并且执行回调函数
            };

            //根据状态处理回调
            function handleFun(){
                var promise = this,isThen;

                if (_state === PROMISESTATE.FULFILLED &amp;&amp;
                    typeof promise._fullCalll[0] === &apos;function&apos;) {
                    isThen = promise._fullCalll[0](_value);
                };
                if (_state === PROMISESTATE.REJECTED &amp;&amp;
                    typeof promise._rejCall[0] === &apos;function&apos;) {
                    isThen = promise._rejCall[0](_value);
                };
                //对于是否可以继续进行then做判断
                //  1. 不可then的，直接return结束（条件：无返回值、返回值不是promise对象的）
                //  2. 对于可以then的，将then的回调进行处理，然后对象之间传递。
                if (isThen === undefined || !(typeof isThen === &apos;object&apos; &amp;&amp; isThen._name === &apos;promise&apos;)) return;

                promise._fullCalll.shift(); promise._rejCall.shift();      //清除当前对象使用过的对调
                isThen._fullCalll =promise._fullCalll;isThen._rejCall = promise._rejCall;  //将剩下的回调传递到下一个对象
            };

            //promimse入口
            function doResolve(fn){
                var promise = this;
                fn(function(param) {
                    setState.call(promise,PROMISESTATE.FULFILLED,param);
                }, function(reason) {
                    setState.call(promise,PROMISESTATE.REJECTED,reason);
                });
            };

            //函数then，处理回调，返回对象保证链式调用
            this.then = function(onFulfilled,onRejected) {
                this._fullCalll.push(onFulfilled);
                this._rejCall.push(onRejected);
                return this;
            }

            doResolve.call(promise,fn);
        };
        window.Promise = newPromise;
    },

};

var tempObj ={
    //通用ajax
    common:function(options){
        //每次清空请求缓存,并重新合并对象
        var ajaxSetting = {},sendData=null;tool.MergeObject(ajaxSetting,initParam);tool.MergeObject(ajaxSetting,options);

        //创建xhr对象
        var xhr = tool.createXhrObject();

        //针对某些特定版本的mozillar浏览器的BUG进行修正
        xhr.overrideMimeType?(xhr.overrideMimeType(&quot;text/javascript&quot;)):(null);

        //针对IE8的xhr做处理    PS：ie8下的xhr无xhr.onload事件，所以这里做判断
        xhr.onload===undefined?(xhr.xhr_ie8=true):(xhr.xhr_ie8=false);

        //参数处理（get和post）,包括xhr.open     get:拼接好url再open   post:先open，再设置其他参数
        ajaxSetting.data === &quot;&quot;?(xhr.open(ajaxSetting.type.toUpperCase(), ajaxSetting.url, ajaxSetting.async)):(xhr = tool.dealWithParam(ajaxSetting,this,xhr));

        //设置超时时间（只有异步请求才有超时时间）
        ajaxSetting.async?(xhr.timeoutEvent = ajaxSetting.timeout):(null);

        //设置http协议的头部
        tool.each(ajaxSetting.requestHeader,function(item,index){xhr.setRequestHeader(index,item)});

        //onload事件（IE8下没有该事件）
        xhr.onload = function(e) {
            if(this.status == 200||this.status == 304){
                ajaxSetting.dataType.toUpperCase() == &quot;JSON&quot;?(ajaxSetting.successEvent(JSON.parse(xhr.responseText))):(ajaxSetting.successEvent(xhr.responseText));
            }else{
                /*
                 *  这边为了兼容IE8、9的问题，以及请求完成而造成的其他错误，比如404等
                 *   如果跨域请求在IE8、9下跨域失败不走onerror方法
                 *       其他支持了Level 2 的版本 直接走onerror
                 * */
                ajaxSetting.errorEvent(e.currentTarget.status, e.currentTarget.statusText);
            }
        };

        //xmlhttprequest每次变化一个状态所监控的事件（可拓展）
        xhr.onreadystatechange = function(){
            switch(xhr.readyState){
                case 1://打开
                    //do something
                    break;
                case 2://获取header
                    //do something
                    break;
                case 3://请求
                    //do something
                    break;
                case 4://完成
                    //在ie8下面，无xhr的onload事件，只能放在此处处理回调结果
                    xhr.xhr_ie8?((xhr.status == 200 || xhr.status == 304)?(ajaxSetting.dataType.toUpperCase() == &quot;JSON&quot;?(ajaxSetting.successEvent(JSON.parse(xhr.responseText))):(ajaxSetting.successEvent(xhr.responseText))):(null)):(null);
                    break;
            };
        };

        //ontimeout超时事件
        xhr.ontimeout = function(e){
            ajaxSetting.timeoutEvent(999,e?(e.type):(&quot;timeoutEvent&quot;));   //IE8 没有e参数
            xhr.abort();  //关闭请求
        };

        //错误事件，直接ajax失败，而不走onload事件
        xhr.onerror = function(e){
            ajaxSetting.errorEvent();
        };

        if(this.postParam){
            (this.postParam)?(sendData = this.postParam):(sendData = null);
        }else{
            sendData = ajaxSetting.data;
        }

        //发送请求
        xhr.send(sendData);
    },
    //异步get请求
    get:function(url,data,successEvent,errorEvent,timeoutEvent){
        var ajaxParam ={
            type:&quot;get&quot;,
            url:url,
            data:data,
            async:true,
            isFormData:false,
            successEvent:successEvent,
            errorEvent:errorEvent,
            timeoutEvent:timeoutEvent
        };
        ajax.common(ajaxParam);
    },
    //异步post请求
    post:function(url,data,successEvent,errorEvent,timeoutEvent){
        var ajaxParam ={
            type:&quot;post&quot;,
            url:url,
            data:data,
            async:true,
            isFormData:false,
            successEvent:successEvent,
            errorEvent:errorEvent,
            timeoutEvent:timeoutEvent
        };
        ajax.common(ajaxParam);
    },
    //异步post请求
    postFormData:function(url,formData,successEvent,errorEvent,timeoutEvent){
        var ajaxParam ={
            type:&quot;post&quot;,
            url:url,
            data:formData,
            async:true,
            isFormData:true,
            successEvent:successEvent,
            errorEvent:errorEvent,
            timeoutEvent:timeoutEvent
        };
        ajax.common(ajaxParam);
    },
    //同步post请求
    postSync:function(url,data,successEvent,errorEvent,timeoutEvent){
        var ajaxParam ={
            type:&quot;post&quot;,
            url:url,
            data:data,
            async:false,
            isFormData:false,
            successEvent:successEvent,
            errorEvent:errorEvent,
            timeoutEvent:timeoutEvent
        };
        ajax.common(ajaxParam);
    },
    //集成promise的ajax请求(默认设置post和get请求，如有其他需求，可自己拓展)
    promiseAjax:function (url,data,type){
        if (!window.Promise) tool.createPromise();  //保证浏览器的兼容性
        return new Promise(function(resolve, reject){
            if (type === undefined) ajax.post(url,data,resolve,reject);
                else ajax.get(url,data,resolve,reject);
        });
    },
    /*
     * 长轮询的实现
     *   param: type  请求类型
     *          url   请求接口地址
     *          data  请求参数
     *          successEvent(data,this)     成功事件处理  如果得到正确数据，则让轮询停止，则在第二个回调参数设置stop属性就好
     *          timeFrequency               每隔多少时间发送一次请求
     *          errorEvent                  错误事件
     *          timeoutEvent                超时处理
     * */
    longPolling:function(type,url,data,successEvent,timeFrequency,errorEvent,timeoutEvent){
        var ajaxParam ={
            type:type,
            url:url,
            data:data,
            async:true,
            isFormData:false,
            successEvent:function(dateCall){
                successEvent(dateCall,this);
                if (!this.stop){
                    setTimeout(function(){
                        tempObj.longPolling(type,url,data,successEvent,timeFrequency,errorEvent,timeoutEvent);
                    },timeFrequency);
                };
            },
            //如果走了error说明该接口有问题，没必要继续下去了
            errorEvent:errorEvent,
            timeoutEvent:function(){
                timeoutEvent();
                setTimeout(function(){
                    tempObj.longPolling(type,url,data,successEvent,timeFrequency,errorEvent,timeoutEvent)
                },timeFrequency);
            }
        };
        ajax.common(ajaxParam);
    },
    /*
     *   ajax上传文件 -- level2的新特性，请保证你的项目支持新的特性再使用
     *       url                 文件上传地址
     *       fileSelector        input=file 选择器
     *       size                文件限制大小
     *       fileType            文件限制类型 mime类型
     *       successEvent             上传成功处理
     *       errorEvent               上传失败处理
     *       timeoutEvent             超时处理
     *
     *   return: status:  0      请选择文件
     *                    1      超出文件限制大小
     *                    2      非允许文件格式
     * */
    upload:function(url,fileSelector,size,fileType,successEvent,errorEvent,timeoutEvent){
        var formdata = new FormData(),fileNode = document.querySelector(fileSelector),fileCount = fileNode.files.length,data={},result ={};
        //以下为上传文件限制检查
        if ( fileCount &gt; 0 ){
            tool.each(Array.prototype.slice.call(fileNode.files),function(value){
                //检查文件大小
                if (value.size &gt; size){
                    result[&quot;status&quot;] = 1;
                    result[&quot;errMsg&quot;] = &quot;超出文件限制大小&quot;;
                }else{
                    if (fileType != &quot;*&quot;){
                        //检查文件格式.因为支持formdata，自然支持数组的indexof(h5)
                        if (fileType.indexOf(value.type)=== -1 ){
                            result[&quot;status&quot;] = 2;
                            result[&quot;errMsg&quot;] = &quot;非允许文件格式&quot;;
                        }else{
                            formdata.append(value.name,value);
                        };
                    }else{
                        formdata.append(value.name,value);
                    }
                };
            });
        }else{
            result[&quot;status&quot;] = 0;
            result[&quot;errMsg&quot;] = &quot;请选择文件&quot;;
        };

        if (result.status !== undefined)  return result;   //如果有错误信息直接抛出去,结束运行

        var ajaxParam ={
            type:&quot;post&quot;,
            url:url,
            data:formdata,
            isFormData:true,
            successEvent:successEvent,
            errorEvent:errorEvent,
            timeoutEvent:timeoutEvent
        };
        ajax.common(ajaxParam);
    },
    /*
     *   ajax大文件切割上传(支持单个文件)  -- level2的新特性，请保证你的项目支持新的特性再使用
     *       url                 文件上传地址
     *       fileSelector        input=file 选择器
     *       cutSize             切割文件大小
     *       fileType            文件限制类型 mime类型
     *       successEvent        上传成功处理
     *       progressEvent       上传进度事件
     *       errorEvent          上传失败处理
     *       timeoutEvent        超时处理事件
     *
     *   return: status:  0      请选择文件
     *                    1      非允许文件格式
     * */
    upload_big:function(url,fileSelector,cutSize,fileType,successEvent,progressEvent,errorEvent,timeoutEvent){
        var file = document.querySelector(fileSelector).files,result ={};
        //以下为上传文件限制检查
        if (file.length === 1){
            if (fileType != &quot;*&quot;){
                if (fileType.indexOf(file.type)=== -1 ){
                    result[&quot;status&quot;] = 1;
                    result[&quot;errMsg&quot;] = &quot;非允许文件格式&quot;;
                }
            }
        }else{
            result[&quot;status&quot;] = 0;
            result[&quot;errMsg&quot;] = &quot;请选择文件/只能上传一个文件&quot;;
        };

        if (result.status !== undefined)  return result;   //如果有错误信息直接抛出去,结束运行

        //判断上传文件是否超过需要切割的大小
        if (file[0].size &gt; cutSize){
            var fileArr = tool.cutFile(file[0],cutSize);  //切割文件
            cutFile_upload(fileArr);
        }else{
            return tempObj.upload(url,fileSelector,file[0].size,fileType,successEvent,errorEvent,timeoutEvent);
        };

        /*
         *   切割文件上传，配合后台接口进行对接
         *       传输参数：
         *           count   -- 当前传输part的次数
         *           name    -- 做过处理的文件名称
         *           file    -- 上传的.part的切割文件
         *           isLast  -- 是否为最后一次切割文件上传（默认值：&quot;true&quot;  字符串，只有最后一次才附加）
         * */
        function cutFile_upload(fileArr,count){
            var formData = new FormData();
            if (count == undefined){
                count = 0;
                formData.append(&quot;count&quot;,count);
                formData.append(&quot;name&quot;,fileArr[0].name);
                formData.append(&quot;file&quot;.name,fileArr[0].file);
            }else{
                if (count === fileArr.length-1){
                    formData.append(&quot;isLast&quot;,&quot;true&quot;)
                };
                formData.append(&quot;count&quot;,count);
                formData.append(&quot;name&quot;,fileArr[count].name);
                formData.append(&quot;file&quot;.name,fileArr[count].file);
            };
            var ajaxParam ={
                type:&quot;post&quot;,
                url:url,
                data:formData,
                isFormData:true,
                successEvent:function(data){
                    /*
                     *   data 参数设置  需要后台接口配合
                     *       建议：如果后台成功保存.part文件，建议返回下次所需要的部分，比如当前发送count为0，则data返回下次为1。
                     *             如果保存不成功，则可false，或者返回错误信息，可在successEvent中处理
                     *
                     * */
                    progressEvent(count+1,fileArr.length);   //上传进度事件，第一个参数：当前上传次数；第二个参数：总共文件数

                    var currCount = Number(data);
                    if (currCount){
                        if (currCount != fileArr.length){
                            cutFile_upload(fileArr,currCount);
                        };
                    };
                    successEvent(data);  //成功处理事件
                },
                errorEvent:errorEvent,
                timeoutEvent:timeoutEvent
            };
            ajax.common(ajaxParam);
        }
    }
};

var outputObj = function(){
    //虽然在IE6、7上可以支持，但是最好升级你的浏览器，毕竟xp已经淘汰，面向未来吧，骚年，和我一起努力吧！！
    if( tool.getIEVersion() &lt; 7 ){
        //实在不想说：lowB，升级你的浏览器吧
        throw new Error (&quot;Sorry,please upgrade your browser.(IE8+)&quot;);
    }
    return tempObj;
};

window.ajax = new outputObj();
</code></pre><p>})(this);</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-深拷贝" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/08/深拷贝/" class="article-date">
  	<time datetime="2016-06-07T16:00:00.000Z" itemprop="datePublished">2016-06-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/08/深拷贝/">克隆或者拷贝</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>克隆或者拷贝分为2种：浅度克隆（拷贝），深度克隆（拷贝）；</p>
<p>浅度克隆：基本类型为值传递，对象仍为引用传递。</p>
<p>深度克隆：所有元素或属性均完全克隆，并于原引用类型完全独立，即，在后面修改对象的属性的时候，原对象不会被修改。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/06/08/深拷贝/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-老ie解决方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/30/老ie解决方法/" class="article-date">
  	<time datetime="2016-05-29T16:00:00.000Z" itemprop="datePublished">2016-05-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/30/老ie解决方法/">老ie解决方法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一行代码解决各种IE兼容问题,IE6,IE7,IE8,IE9,IE10</p>
<p>x-ua-compatible 用来指定IE浏览器解析编译页面的model</p>
<p>x-ua-compatible 头标签大小写不敏感，必须用在 head 中，必须在除 title 外的其他 meta 之前使用。</p>
<p>1、使用一行代码来指定浏览器使用特定的文档模式。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;meta http-equiv=&#34;x-ua-compatible&#34; content=&#34;IE=9&#34; &#62;&#10;&#60;meta http-equiv=&#34;x-ua-compatible&#34; content=&#34;IE=8&#34; &#62;&#10;&#60;meta http-equiv=&#34;x-ua-compatible&#34; content=&#34;IE=7&#34; &#62;</span><br></pre></td></tr></table></figure></p>
<p>2、在一些情况下，我们需要限定浏览器对文档的解析到某一特定版本，或者将浏览器限定到一些旧版本的表现中。可以用如下的方式：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;meta http-equiv=&#34;x-ua-compatible&#34; content=&#34;IE=EmulateIE9&#34; &#62;&#10;&#60;meta http-equiv=&#34;x-ua-compatible&#34; content=&#34;IE=EmulateIE8&#34; &#62;&#10;&#60;meta http-equiv=&#34;x-ua-compatible&#34; content=&#34;IE=EmulateIE7&#34; &#62;</span><br></pre></td></tr></table></figure></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/兼容/">兼容</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/05/30/老ie解决方法/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div>&copy; 2017 任先生在路上 的博客 , 技术 
        <a href="http://hexo.io/" target="_blank">Hexo</a>  
      </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>