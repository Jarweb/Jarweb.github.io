<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Jar-R</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Hi">
<meta property="og:type" content="website">
<meta property="og:title" content="Jar-R">
<meta property="og:url" content="http://Jarweb.com/page/5/index.html">
<meta property="og:site_name" content="Jar-R">
<meta property="og:description" content="Hi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jar-R">
<meta name="twitter:description" content="Hi">
  
    <link rel="alternative" href="/atom.xml" title="Jar-R" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">任先生在路上</a></h1>
		</hgroup>

		
		<p class="header-subtitle" style="margin-bottom:20px;">Good things are coming !</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger" style="display:none;"></div>
  		<h1 class="header-author js-mobile-header hide">任先生在路上</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">任先生在路上</h1>
			</hgroup>
			
			<p class="header-subtitle">Good things are coming !</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-居中" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/14/居中/" class="article-date">
  	<time datetime="2016-06-13T16:00:00.000Z" itemprop="datePublished">2016-06-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/14/居中/">css居中</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>水平居中<br>内联元素（inline or inline-*）居中?<br>你可以让他相对父级块级元素居中对齐<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.center-children &#123;&#10;  text-align: center;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>块级元素（block level）居中?<br>你可以通过设置margin-left和margin-right为auto让它居中（同时还要设置width，否则它就会承满整个容器，无法看出居中效果），如。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.center-me &#123;&#10;  margin: 0 auto;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/06/14/居中/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ajax2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/12/ajax2/" class="article-date">
  	<time datetime="2016-06-11T16:00:00.000Z" itemprop="datePublished">2016-06-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/12/ajax2/">ajax</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>(function(window){<br>    var initParam ={<br>        timeout:0,                                  //超时时间（单位：毫秒）<br>        type:””,                                    //请求类型（get、post…）<br>        url:””,                                     //请求接口<br>        data:””,                                    //请求参数（格式：json对象）  例子：{“name”:”gerry”,”age”:”88”}<br>        async:true,                                 //同|异步请求 （异步：true 同步：false）<br>        dataType:’’,                                //返回值处理（可拓展）   目前只实现：JSON<br>        isFormData:false,                              //是否为formData传输方式  ajax-level2方案  PS：因为使用formData数据传输，后台接口需要变化，数据取值将要在request的form对象中取值<br>        successEvent:function(data){},             //请求成功处理事件<br>        errorEvent:function(x,xx,xxx){},           //请求失败处理事件<br>        timeoutEvent:function(){},                 //请求超时处理事件<br>        requestHeader:{}                            //报文头设置（可自定义报文头）<br>    };<br>    var tool = {<br>        hasOwn: function(obj, key){<br>            return Object.prototype.hasOwnProperty.call(obj, key)<br>        },<br>        //类型判断<br>        is:(function checkType(){<br>            var is ={<br>                types : [“Array”, “Boolean”, “Date”, “Number”, “Object”, “RegExp”, “String”, “Window”, “HTMLDocument”]<br>            };<br>            for(var i = 0, c; c = is.types[i ++ ]; ){<br>                is[c] = (function(type){<br>                    return function(obj){<br>                        var temp = Object.prototype.toString.call(obj) == “[object “ + type + “]”;<br>                        if (temp) temp = obj;<br>                        return temp;<br>                    }<br>                })(c);<br>            };<br>            return is;<br>        })(),<br>        //获取对象的key<br>        keys: function(obj){<br>            if(Object.keys) return Object.keys(obj);</p>
<pre><code>        var keys = [];
        for(var key in obj){
            if(this.hasOwn(obj, key)) keys.push(key);
        };
        return keys
    },
    //each循环
    each:function(obj,callback){
        var keys = this.keys(obj);
        if (this.is.Array(obj)&amp;&amp;[].forEach){  //判断是否为数组且支持新特性
            obj.forEach(callback);
        }else{
            var i = 0, len = keys.length, key, item;
            while( i &lt; len ){
                key = keys[i++];
                item = obj[key];
                callback.call(obj, item, key);
            }
        }
    },
    //合并对象,将第二个合并到第一个对象上
    MergeObject:function(target,source){
        if(Object.assign){
            return Object.assign(target, source)
        }
        var targetKeys = this.keys(target),
            sourceKeys = this.keys(source),
            i = 0
        var len = sourceKeys.length;
        while( i &lt; len ){
            var key = sourceKeys[i++]
            target[key] = source[key];
        }
        return target;
    },
    //创建xhr对象
    createXhrObject:function(){
        var xhr;
        try{
            // IE7 已经有了XMLHttpRequest对象
            XMLHttpRequest?(xhr= new XMLHttpRequest()):(xhr= new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;));
        }catch (e){
            throw new Error(&apos;ajax:Could not create an XHR object.&apos;)
        };
        return xhr;
    },
    //ajax参数处理，可拓展
    dealWithParam:function(ajaxSetting,that,xhr){
        switch (ajaxSetting.type.toUpperCase()) {
            case &quot;GET&quot;:
                var getParam = &quot;?&quot;;
                tool.each(ajaxSetting.data,function(item,index){
                    getParam +=(encodeURI(index)+&quot;=&quot;+encodeURI(item)+&quot;&amp;&quot;)
                });
                //处理最后一位&quot;&amp;&quot;符号，其实不处理也没事，强迫症犯了，尴尬
                getParam =getParam.substr(0,getParam.length-1);
                //打开请求
                xhr.open(ajaxSetting.type.toUpperCase(), ajaxSetting.url+=getParam, ajaxSetting.async);
                break;
            case &quot;POST&quot;:
                //打开请求
                xhr.open(ajaxSetting.type.toUpperCase(), ajaxSetting.url, ajaxSetting.async);
                xhr.setRequestHeader(&quot;Accept&quot;,&quot;*/*&quot;);   //解决火狐浏览器默认要求后台发送xml类型返回值
                /*
                 *  1、 判断浏览器是否支持level2的属性
                 *       a、 支持。判断用户配置中是否设定使用formdata传输数据
                 *       b、 不支持。默认使用level1的传统发过誓传输数据
                 * */
                that.postParam = undefined;
                if(!(window.FormData &amp;&amp; ajaxSetting.isFormData)){
                    xhr.setRequestHeader(&quot;content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
                    var postParam =&quot;&quot;;
                    tool.each(ajaxSetting.data,function(item,index){
                        postParam +=(index+&quot;=&quot;+item+&quot;&amp;&quot;)
                    });
                    //处理最后一位&quot;&amp;&quot;符号，其实不处理也没事，强迫症犯了，尴尬
                    postParam =postParam.substr(0,postParam.length-1);
                    that.postParam = postParam;
                }
                break;
        };
        return xhr;
    },
    //判断IE版本
    // 如果不是IE，返回 true
    // 若是IE，返回IE版本号
    getIEVersion:function(){
        return function() {
            // 能进到这里来，说明一定是IE
            if (window.VBArray) {
                // 取出IE的版本
                var mode = document.documentMode
                // IE6、IE7 不支持documentMode，那就使用XMLHttpRequest，支持的就是IE7，否则就是IE6
                // 至于支持documentMode的IE，则直接return
                return mode ? mode : window.XMLHttpRequest ? 7 : 6
            } else {
                return NaN
            }
        }()
    },
    //切割大文件
    cutFile:function(file,cutSize){
        var count = file.size / cutSize | 0 ,fileArr = [];
        for (var i= 0; i&lt; count ; i++){
            fileArr.push({
                name:file.name+&quot;.part&quot;+(i+1),
                file:file.slice( cutSize * i , cutSize * ( i + 1 ))
            });
        };
        fileArr.push({
            name:file.name+&quot;.part&quot;+(count+1),
            file:file.slice(cutSize*count,file.size)
        });
        return fileArr;
    },
    //如果浏览器不支持Promise特性，将用简易的promise代替(IE11-都不支持ES6 Promise)
    createPromise:function(){
        var newPromise = function(fn){
            var promise = this;
            //状态机的状态
            var PROMISESTATE = {
                PENDING : 0 ,
                FULFILLED : 1 ,
                REJECTED : 2
            };
            //存储当前变量的回调函数和标记对象为promise
            promise._fullCalll =[],promise._rejCall = [];promise._name = &quot;promise&quot;;
            //执行过程中的状态变化(初始化状态为默认状态)
            var _state =  PROMISESTATE.PENDING;
            //回调函数的参数
            var _value = undefined;

            //状态变更
            function setState(stateT,valueT){
                var promise = this;
                _state = stateT;
                _value = valueT;
                handleFun.call(promise);  //传递作用域，并且执行回调函数
            };

            //根据状态处理回调
            function handleFun(){
                var promise = this,isThen;

                if (_state === PROMISESTATE.FULFILLED &amp;&amp;
                    typeof promise._fullCalll[0] === &apos;function&apos;) {
                    isThen = promise._fullCalll[0](_value);
                };
                if (_state === PROMISESTATE.REJECTED &amp;&amp;
                    typeof promise._rejCall[0] === &apos;function&apos;) {
                    isThen = promise._rejCall[0](_value);
                };
                //对于是否可以继续进行then做判断
                //  1. 不可then的，直接return结束（条件：无返回值、返回值不是promise对象的）
                //  2. 对于可以then的，将then的回调进行处理，然后对象之间传递。
                if (isThen === undefined || !(typeof isThen === &apos;object&apos; &amp;&amp; isThen._name === &apos;promise&apos;)) return;

                promise._fullCalll.shift(); promise._rejCall.shift();      //清除当前对象使用过的对调
                isThen._fullCalll =promise._fullCalll;isThen._rejCall = promise._rejCall;  //将剩下的回调传递到下一个对象
            };

            //promimse入口
            function doResolve(fn){
                var promise = this;
                fn(function(param) {
                    setState.call(promise,PROMISESTATE.FULFILLED,param);
                }, function(reason) {
                    setState.call(promise,PROMISESTATE.REJECTED,reason);
                });
            };

            //函数then，处理回调，返回对象保证链式调用
            this.then = function(onFulfilled,onRejected) {
                this._fullCalll.push(onFulfilled);
                this._rejCall.push(onRejected);
                return this;
            }

            doResolve.call(promise,fn);
        };
        window.Promise = newPromise;
    },

};

var tempObj ={
    //通用ajax
    common:function(options){
        //每次清空请求缓存,并重新合并对象
        var ajaxSetting = {},sendData=null;tool.MergeObject(ajaxSetting,initParam);tool.MergeObject(ajaxSetting,options);

        //创建xhr对象
        var xhr = tool.createXhrObject();

        //针对某些特定版本的mozillar浏览器的BUG进行修正
        xhr.overrideMimeType?(xhr.overrideMimeType(&quot;text/javascript&quot;)):(null);

        //针对IE8的xhr做处理    PS：ie8下的xhr无xhr.onload事件，所以这里做判断
        xhr.onload===undefined?(xhr.xhr_ie8=true):(xhr.xhr_ie8=false);

        //参数处理（get和post）,包括xhr.open     get:拼接好url再open   post:先open，再设置其他参数
        ajaxSetting.data === &quot;&quot;?(xhr.open(ajaxSetting.type.toUpperCase(), ajaxSetting.url, ajaxSetting.async)):(xhr = tool.dealWithParam(ajaxSetting,this,xhr));

        //设置超时时间（只有异步请求才有超时时间）
        ajaxSetting.async?(xhr.timeoutEvent = ajaxSetting.timeout):(null);

        //设置http协议的头部
        tool.each(ajaxSetting.requestHeader,function(item,index){xhr.setRequestHeader(index,item)});

        //onload事件（IE8下没有该事件）
        xhr.onload = function(e) {
            if(this.status == 200||this.status == 304){
                ajaxSetting.dataType.toUpperCase() == &quot;JSON&quot;?(ajaxSetting.successEvent(JSON.parse(xhr.responseText))):(ajaxSetting.successEvent(xhr.responseText));
            }else{
                /*
                 *  这边为了兼容IE8、9的问题，以及请求完成而造成的其他错误，比如404等
                 *   如果跨域请求在IE8、9下跨域失败不走onerror方法
                 *       其他支持了Level 2 的版本 直接走onerror
                 * */
                ajaxSetting.errorEvent(e.currentTarget.status, e.currentTarget.statusText);
            }
        };

        //xmlhttprequest每次变化一个状态所监控的事件（可拓展）
        xhr.onreadystatechange = function(){
            switch(xhr.readyState){
                case 1://打开
                    //do something
                    break;
                case 2://获取header
                    //do something
                    break;
                case 3://请求
                    //do something
                    break;
                case 4://完成
                    //在ie8下面，无xhr的onload事件，只能放在此处处理回调结果
                    xhr.xhr_ie8?((xhr.status == 200 || xhr.status == 304)?(ajaxSetting.dataType.toUpperCase() == &quot;JSON&quot;?(ajaxSetting.successEvent(JSON.parse(xhr.responseText))):(ajaxSetting.successEvent(xhr.responseText))):(null)):(null);
                    break;
            };
        };

        //ontimeout超时事件
        xhr.ontimeout = function(e){
            ajaxSetting.timeoutEvent(999,e?(e.type):(&quot;timeoutEvent&quot;));   //IE8 没有e参数
            xhr.abort();  //关闭请求
        };

        //错误事件，直接ajax失败，而不走onload事件
        xhr.onerror = function(e){
            ajaxSetting.errorEvent();
        };

        if(this.postParam){
            (this.postParam)?(sendData = this.postParam):(sendData = null);
        }else{
            sendData = ajaxSetting.data;
        }

        //发送请求
        xhr.send(sendData);
    },
    //异步get请求
    get:function(url,data,successEvent,errorEvent,timeoutEvent){
        var ajaxParam ={
            type:&quot;get&quot;,
            url:url,
            data:data,
            async:true,
            isFormData:false,
            successEvent:successEvent,
            errorEvent:errorEvent,
            timeoutEvent:timeoutEvent
        };
        ajax.common(ajaxParam);
    },
    //异步post请求
    post:function(url,data,successEvent,errorEvent,timeoutEvent){
        var ajaxParam ={
            type:&quot;post&quot;,
            url:url,
            data:data,
            async:true,
            isFormData:false,
            successEvent:successEvent,
            errorEvent:errorEvent,
            timeoutEvent:timeoutEvent
        };
        ajax.common(ajaxParam);
    },
    //异步post请求
    postFormData:function(url,formData,successEvent,errorEvent,timeoutEvent){
        var ajaxParam ={
            type:&quot;post&quot;,
            url:url,
            data:formData,
            async:true,
            isFormData:true,
            successEvent:successEvent,
            errorEvent:errorEvent,
            timeoutEvent:timeoutEvent
        };
        ajax.common(ajaxParam);
    },
    //同步post请求
    postSync:function(url,data,successEvent,errorEvent,timeoutEvent){
        var ajaxParam ={
            type:&quot;post&quot;,
            url:url,
            data:data,
            async:false,
            isFormData:false,
            successEvent:successEvent,
            errorEvent:errorEvent,
            timeoutEvent:timeoutEvent
        };
        ajax.common(ajaxParam);
    },
    //集成promise的ajax请求(默认设置post和get请求，如有其他需求，可自己拓展)
    promiseAjax:function (url,data,type){
        if (!window.Promise) tool.createPromise();  //保证浏览器的兼容性
        return new Promise(function(resolve, reject){
            if (type === undefined) ajax.post(url,data,resolve,reject);
                else ajax.get(url,data,resolve,reject);
        });
    },
    /*
     * 长轮询的实现
     *   param: type  请求类型
     *          url   请求接口地址
     *          data  请求参数
     *          successEvent(data,this)     成功事件处理  如果得到正确数据，则让轮询停止，则在第二个回调参数设置stop属性就好
     *          timeFrequency               每隔多少时间发送一次请求
     *          errorEvent                  错误事件
     *          timeoutEvent                超时处理
     * */
    longPolling:function(type,url,data,successEvent,timeFrequency,errorEvent,timeoutEvent){
        var ajaxParam ={
            type:type,
            url:url,
            data:data,
            async:true,
            isFormData:false,
            successEvent:function(dateCall){
                successEvent(dateCall,this);
                if (!this.stop){
                    setTimeout(function(){
                        tempObj.longPolling(type,url,data,successEvent,timeFrequency,errorEvent,timeoutEvent);
                    },timeFrequency);
                };
            },
            //如果走了error说明该接口有问题，没必要继续下去了
            errorEvent:errorEvent,
            timeoutEvent:function(){
                timeoutEvent();
                setTimeout(function(){
                    tempObj.longPolling(type,url,data,successEvent,timeFrequency,errorEvent,timeoutEvent)
                },timeFrequency);
            }
        };
        ajax.common(ajaxParam);
    },
    /*
     *   ajax上传文件 -- level2的新特性，请保证你的项目支持新的特性再使用
     *       url                 文件上传地址
     *       fileSelector        input=file 选择器
     *       size                文件限制大小
     *       fileType            文件限制类型 mime类型
     *       successEvent             上传成功处理
     *       errorEvent               上传失败处理
     *       timeoutEvent             超时处理
     *
     *   return: status:  0      请选择文件
     *                    1      超出文件限制大小
     *                    2      非允许文件格式
     * */
    upload:function(url,fileSelector,size,fileType,successEvent,errorEvent,timeoutEvent){
        var formdata = new FormData(),fileNode = document.querySelector(fileSelector),fileCount = fileNode.files.length,data={},result ={};
        //以下为上传文件限制检查
        if ( fileCount &gt; 0 ){
            tool.each(Array.prototype.slice.call(fileNode.files),function(value){
                //检查文件大小
                if (value.size &gt; size){
                    result[&quot;status&quot;] = 1;
                    result[&quot;errMsg&quot;] = &quot;超出文件限制大小&quot;;
                }else{
                    if (fileType != &quot;*&quot;){
                        //检查文件格式.因为支持formdata，自然支持数组的indexof(h5)
                        if (fileType.indexOf(value.type)=== -1 ){
                            result[&quot;status&quot;] = 2;
                            result[&quot;errMsg&quot;] = &quot;非允许文件格式&quot;;
                        }else{
                            formdata.append(value.name,value);
                        };
                    }else{
                        formdata.append(value.name,value);
                    }
                };
            });
        }else{
            result[&quot;status&quot;] = 0;
            result[&quot;errMsg&quot;] = &quot;请选择文件&quot;;
        };

        if (result.status !== undefined)  return result;   //如果有错误信息直接抛出去,结束运行

        var ajaxParam ={
            type:&quot;post&quot;,
            url:url,
            data:formdata,
            isFormData:true,
            successEvent:successEvent,
            errorEvent:errorEvent,
            timeoutEvent:timeoutEvent
        };
        ajax.common(ajaxParam);
    },
    /*
     *   ajax大文件切割上传(支持单个文件)  -- level2的新特性，请保证你的项目支持新的特性再使用
     *       url                 文件上传地址
     *       fileSelector        input=file 选择器
     *       cutSize             切割文件大小
     *       fileType            文件限制类型 mime类型
     *       successEvent        上传成功处理
     *       progressEvent       上传进度事件
     *       errorEvent          上传失败处理
     *       timeoutEvent        超时处理事件
     *
     *   return: status:  0      请选择文件
     *                    1      非允许文件格式
     * */
    upload_big:function(url,fileSelector,cutSize,fileType,successEvent,progressEvent,errorEvent,timeoutEvent){
        var file = document.querySelector(fileSelector).files,result ={};
        //以下为上传文件限制检查
        if (file.length === 1){
            if (fileType != &quot;*&quot;){
                if (fileType.indexOf(file.type)=== -1 ){
                    result[&quot;status&quot;] = 1;
                    result[&quot;errMsg&quot;] = &quot;非允许文件格式&quot;;
                }
            }
        }else{
            result[&quot;status&quot;] = 0;
            result[&quot;errMsg&quot;] = &quot;请选择文件/只能上传一个文件&quot;;
        };

        if (result.status !== undefined)  return result;   //如果有错误信息直接抛出去,结束运行

        //判断上传文件是否超过需要切割的大小
        if (file[0].size &gt; cutSize){
            var fileArr = tool.cutFile(file[0],cutSize);  //切割文件
            cutFile_upload(fileArr);
        }else{
            return tempObj.upload(url,fileSelector,file[0].size,fileType,successEvent,errorEvent,timeoutEvent);
        };

        /*
         *   切割文件上传，配合后台接口进行对接
         *       传输参数：
         *           count   -- 当前传输part的次数
         *           name    -- 做过处理的文件名称
         *           file    -- 上传的.part的切割文件
         *           isLast  -- 是否为最后一次切割文件上传（默认值：&quot;true&quot;  字符串，只有最后一次才附加）
         * */
        function cutFile_upload(fileArr,count){
            var formData = new FormData();
            if (count == undefined){
                count = 0;
                formData.append(&quot;count&quot;,count);
                formData.append(&quot;name&quot;,fileArr[0].name);
                formData.append(&quot;file&quot;.name,fileArr[0].file);
            }else{
                if (count === fileArr.length-1){
                    formData.append(&quot;isLast&quot;,&quot;true&quot;)
                };
                formData.append(&quot;count&quot;,count);
                formData.append(&quot;name&quot;,fileArr[count].name);
                formData.append(&quot;file&quot;.name,fileArr[count].file);
            };
            var ajaxParam ={
                type:&quot;post&quot;,
                url:url,
                data:formData,
                isFormData:true,
                successEvent:function(data){
                    /*
                     *   data 参数设置  需要后台接口配合
                     *       建议：如果后台成功保存.part文件，建议返回下次所需要的部分，比如当前发送count为0，则data返回下次为1。
                     *             如果保存不成功，则可false，或者返回错误信息，可在successEvent中处理
                     *
                     * */
                    progressEvent(count+1,fileArr.length);   //上传进度事件，第一个参数：当前上传次数；第二个参数：总共文件数

                    var currCount = Number(data);
                    if (currCount){
                        if (currCount != fileArr.length){
                            cutFile_upload(fileArr,currCount);
                        };
                    };
                    successEvent(data);  //成功处理事件
                },
                errorEvent:errorEvent,
                timeoutEvent:timeoutEvent
            };
            ajax.common(ajaxParam);
        }
    }
};

var outputObj = function(){
    //虽然在IE6、7上可以支持，但是最好升级你的浏览器，毕竟xp已经淘汰，面向未来吧，骚年，和我一起努力吧！！
    if( tool.getIEVersion() &lt; 7 ){
        //实在不想说：lowB，升级你的浏览器吧
        throw new Error (&quot;Sorry,please upgrade your browser.(IE8+)&quot;);
    }
    return tempObj;
};

window.ajax = new outputObj();
</code></pre><p>})(this);</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-深拷贝" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/08/深拷贝/" class="article-date">
  	<time datetime="2016-06-07T16:00:00.000Z" itemprop="datePublished">2016-06-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/08/深拷贝/">克隆或者拷贝</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>克隆或者拷贝分为2种：浅度克隆（拷贝），深度克隆（拷贝）；</p>
<p>浅度克隆：基本类型为值传递，对象仍为引用传递。</p>
<p>深度克隆：所有元素或属性均完全克隆，并于原引用类型完全独立，即，在后面修改对象的属性的时候，原对象不会被修改。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/06/08/深拷贝/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-老ie解决方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/30/老ie解决方法/" class="article-date">
  	<time datetime="2016-05-29T16:00:00.000Z" itemprop="datePublished">2016-05-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/30/老ie解决方法/">老ie解决方法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一行代码解决各种IE兼容问题,IE6,IE7,IE8,IE9,IE10</p>
<p>x-ua-compatible 用来指定IE浏览器解析编译页面的model</p>
<p>x-ua-compatible 头标签大小写不敏感，必须用在 head 中，必须在除 title 外的其他 meta 之前使用。</p>
<p>1、使用一行代码来指定浏览器使用特定的文档模式。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;meta http-equiv=&#34;x-ua-compatible&#34; content=&#34;IE=9&#34; &#62;&#10;&#60;meta http-equiv=&#34;x-ua-compatible&#34; content=&#34;IE=8&#34; &#62;&#10;&#60;meta http-equiv=&#34;x-ua-compatible&#34; content=&#34;IE=7&#34; &#62;</span><br></pre></td></tr></table></figure></p>
<p>2、在一些情况下，我们需要限定浏览器对文档的解析到某一特定版本，或者将浏览器限定到一些旧版本的表现中。可以用如下的方式：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;meta http-equiv=&#34;x-ua-compatible&#34; content=&#34;IE=EmulateIE9&#34; &#62;&#10;&#60;meta http-equiv=&#34;x-ua-compatible&#34; content=&#34;IE=EmulateIE8&#34; &#62;&#10;&#60;meta http-equiv=&#34;x-ua-compatible&#34; content=&#34;IE=EmulateIE7&#34; &#62;</span><br></pre></td></tr></table></figure></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/兼容/">兼容</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/05/30/老ie解决方法/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-localstore介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/05/localstore介绍/" class="article-date">
  	<time datetime="2016-05-04T16:00:00.000Z" itemprop="datePublished">2016-05-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/05/localstore介绍/">localstore介绍</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>store.js 是一个实现了浏览器的本地存储的 JavaScript 封装 API，不是通过 Cookie 和 Flash 技术实现，而是使用 localStorage。</p>
<p>bower<br>$ bower install storejs</p>
<p>npm<br>$ npm install storejs</p>
<p>生成压缩文件和开发模式<br>$ npm run build    # 生成带UMD的js原文件 以及 min.js<br>$ npm run watch    # 监听文件改变自动压缩生成js</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/localstore/">localstore</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/05/05/localstore介绍/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-滚动条样式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/01/滚动条样式/" class="article-date">
  	<time datetime="2016-04-30T16:00:00.000Z" itemprop="datePublished">2016-05-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/01/滚动条样式/">滚动条样式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ie<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#123;  &#10;    scrollbar-face-color:#F3F3F3; /*&#38754;&#23376;*/  &#10;    scrollbar-arrow-color:#C0C0C0; /*&#31661;&#22836;*/  &#10;    scrollbar-3dlight-color:#C0C0C0; /*&#26368;&#22806;&#24038;*/  &#10;    scrollbar-highlight-color:#FFFFFF; /*&#24038;&#20108;*/  &#10;    scrollbar-shadow-color:#FFFFFF; /*&#21491;&#20108;*/  &#10;    scrollbar-darkshadow-color:#C0C0C0; /*&#21491;&#19968;*/  &#10;    scrollbar-track-color:#F3F3F3; /*&#28369;&#36947;*/  &#10;&#125;</span><br></pre></td></tr></table></figure></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/05/01/滚动条样式/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-模板引擎" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/29/模板引擎/" class="article-date">
  	<time datetime="2016-04-28T16:00:00.000Z" itemprop="datePublished">2016-04-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/29/模板引擎/">模板引擎</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>什么是模板引擎，说的简单点，就是一个字符串中有几个变量待定。比如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var tpl = &#39;Hei, my name is &#60;%name%&#62;, and I\&#39;m &#60;%age%&#62; years old.&#39;;&#10;//&#36890;&#36807;&#27169;&#26495;&#24341;&#25806;&#20989;&#25968;&#25226;&#25968;&#25454;&#22622;&#36827;&#21435;&#65292;&#10;var data = &#123; &#34;name&#34;: &#34;Barret Lee&#34;, &#34;age&#34;: &#34;20&#34; &#125;;&#10;var result = tplEngine(tpl, data);&#10;//Hei, my name is Barret Lee, and I&#39;m 20 years old.</span><br></pre></td></tr></table></figure></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js原生/">js原生</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/04/29/模板引擎/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-模块化深入" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/模块化深入/" class="article-date">
  	<time datetime="2016-04-27T16:00:00.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/模块化深入/">模块化深入</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>装饰者（Decorator）模式：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// mylib/UpdatableObservable&#65306;dojo/store/Observable &#30340;&#19968;&#20010;&#35013;&#39280;&#32773;&#10;define([&#39;dojo&#39;, &#39;dojo/store/Observable&#39;], function ( dojo, Observable ) &#123;&#10;    return function UpdatableObservable ( store ) &#123;&#10;        var observable = dojo.isFunction(store.notify) ? store :new Observable(store);&#10;        observable.updated = function( object ) &#123;&#10;            dojo.when(object, function ( itemOrArray ) &#123;&#10;                dojo.forEach( [].concat(itemOrArray), this.notify, this );&#10;            &#125;;&#10;        &#125;;&#10;        return observable; // &#35753; `new` &#25104;&#20026;&#21487;&#36873;&#30340;&#10;    &#125;;&#10;&#125;);</span><br></pre></td></tr></table></figure></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化/">模块化</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/04/28/模块化深入/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js作用域" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/27/js作用域/" class="article-date">
  	<time datetime="2016-04-26T16:00:00.000Z" itemprop="datePublished">2016-04-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/27/js作用域/">js作用域</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从概念上说，闭包有两个特点：<br> 1、函数<br> 2、能访问另外一个函数作用域中的变量<br> 在ES 6之前，Javascript只有函数作用域的概念，没有块级作用域（但catch捕获的异常 只能在catch块中访问）的概念（IIFE可以创建局部作用域）。每个函数作用域都是封闭的，即外部是访问不到函数作用域中的变量。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getName() &#123;&#10;  var name = &#34;&#32654;&#22899;&#30340;&#21517;&#23383;&#34;;&#10;  console.log(name);     //&#34;&#32654;&#22899;&#30340;&#21517;&#23383;&#34;&#10;&#125;&#10;function displayName() &#123;&#10;    console.log(name);  //&#25253;&#38169;&#10;&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js原生/">js原生</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/04/27/js作用域/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-this指向" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/25/this指向/" class="article-date">
  	<time datetime="2016-04-24T16:00:00.000Z" itemprop="datePublished">2016-04-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/25/this指向/">this指向</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>this指向的四中情况在javascript里面，this的指向可以归纳为以下四种情况。只要能牢记这四种情况，大部分情况下就已经够用了。</p>
<p>1.在全局代码或者普通的函数调用中，this指向全局对象，在浏览器里面既为window对象<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this);&#10;//&#36755;&#20986;window&#10;function foo()&#123;&#10;console.log(this);&#10;&#125;&#10;foo();&#10;//&#36755;&#20986;window</span><br></pre></td></tr></table></figure></p>
<p>在浏览器环境里运行上述代码，两处输出结果均为window对象。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js原生/">js原生</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/04/25/this指向/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div>&copy; 2017 任先生在路上 的博客 , 技术 
        <a href="http://hexo.io/" target="_blank">Hexo</a>  
      </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>