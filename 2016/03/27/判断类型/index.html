<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>判断类型 | Jar-R</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1、使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)：
1let obj = &amp;#123;&amp;#125;;&amp;#10;let arr = [];&amp;#10;console.log(typeof obj === &amp;#39;object&amp;#39;);  &amp;#10">
<meta property="og:type" content="article">
<meta property="og:title" content="判断类型">
<meta property="og:url" content="http://Jarweb.com/2016/03/27/判断类型/index.html">
<meta property="og:site_name" content="Jar-R">
<meta property="og:description" content="1、使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)：
1let obj = &amp;#123;&amp;#125;;&amp;#10;let arr = [];&amp;#10;console.log(typeof obj === &amp;#39;object&amp;#39;);  &amp;#10">
<meta property="og:updated_time" content="2016-05-23T17:56:58.188Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="判断类型">
<meta name="twitter:description" content="1、使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)：
1let obj = &amp;#123;&amp;#125;;&amp;#10;let arr = [];&amp;#10;console.log(typeof obj === &amp;#39;object&amp;#39;);  &amp;#10">
  
    <link rel="alternative" href="/atom.xml" title="Jar-R" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">任先生在路上</a></h1>
		</hgroup>

		
		<p class="header-subtitle" style="margin-bottom:20px;">Good things are coming !</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger" style="display:none;"></div>
  		<h1 class="header-author js-mobile-header hide">任先生在路上</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">任先生在路上</h1>
			</hgroup>
			
			<p class="header-subtitle">Good things are coming !</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-判断类型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/27/判断类型/" class="article-date">
  	<time datetime="2016-03-26T16:00:00.000Z" itemprop="datePublished">2016-03-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      判断类型
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js原生/">js原生</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？<br>使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;&#10;let arr = [];&#10;console.log(typeof obj === &#39;object&#39;);  &#10;//trueconsole.log(typeof arr === &#39;object&#39;);  &#10;//trueconsole.log(typeof null === &#39;object&#39;);  &#10;//true</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>从上面的输出结果可知，typeof bar === “object” 并不能准确判断 bar 就是一个 Object。可以通过Object.prototype.toString.call(bar) === “[object Object]” 来避免这种弊端：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;&#10;let arr = [];&#10;console.log(Object.prototype.toString.call(obj));  &#10;//[object Object]&#10;console.log(Object.prototype.toString.call(arr));  &#10;//[object Array]&#10;console.log(Object.prototype.toString.call(null));  &#10;//[object Null]</span><br></pre></td></tr></table></figure>
<p>另外，为了珍爱生命，请远离 ==：</p>
<p>而 [] === false 是返回 false 的。</p>
<p>2、下面的代码会在 console 输出神马？为什么？<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;&#10;  var a = b = 3;&#10;&#125;)();&#10;console.log(&#34;a defined? &#34; + (typeof a !== &#39;undefined&#39;));   &#10;console.log(&#34;b defined? &#34; + (typeof b !== &#39;undefined&#39;));</span><br></pre></td></tr></table></figure></p>
<p>这跟变量作用域有关，输出换成下面的：<br>console.log(b);<br>//3console,log(typeof a);<br>//undefined<br>拆解一下自执行函数中的变量赋值：<br>b = 3;<br>var a = b;</p>
<p>所以 b 成了全局变量，而 a 是自执行函数的一个局部变量。</p>
<p>3、下面的代码会在 console 输出神马？为什么？<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;&#10;    foo: &#34;bar&#34;,&#10;    func: function() &#123;&#10;        var self = this;&#10;        console.log(&#34;outer func:  this.foo = &#34; + this.foo);&#10;        console.log(&#34;outer func:  self.foo = &#34; + self.foo);&#10;        (function() &#123;&#10;            console.log(&#34;inner func:  this.foo = &#34; + this.foo);&#10;            console.log(&#34;inner func:  self.foo = &#34; + self.foo);&#10;        &#125;());&#10;    &#125;&#10;&#125;;&#10;myObject.func();</span><br></pre></td></tr></table></figure></p>
<p>第一个和第二个的输出不难判断，在 ES6 之前，JavaScript 只有函数作用域，所以 func 中的 IIFE 有自己的独立作用域，并且它能访问到外部作用域中的 self，所以第三个输出会报错，因为 this 在可访问到的作用域内是undefined，第四个输出是 bar。如果你知道闭包，也很容易解决的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function(test) &#123;&#10;            console.log(&#34;inner func:  this.foo = &#34; + test.foo);  //&#39;bar&#39;&#10;            console.log(&#34;inner func:  self.foo = &#34; + self.foo);&#10;&#125;(self));</span><br></pre></td></tr></table></figure></p>
<p>如果对闭包不熟悉，可以戳此：从作用域链谈闭包</p>
<p>4、将 JavaScript 代码包含在一个函数块中有神马意思呢？为什么要这么做？<br>换句话说，为什么要用立即执行函数表达式（Immediately-Invoked Function Expression）。<br>IIFE 有两个比较经典的使用场景，一是类似于在循环中定时输出数据项，二是类似于 JQuery/Node 的插件和模块开发。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &#60; 5; i++) &#123;&#10;    setTimeout(function() &#123;&#10;        console.log(i);  &#10;    &#125;, 1000);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的输出并不是你以为的0，1，2，3，4，而输出的全部是5，这时 IIFE 就能有用了：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &#60; 5; i++) &#123;&#10;    (function(i) &#123;&#10;      setTimeout(function() &#123;&#10;        console.log(i);  &#10;      &#125;, 1000);&#10;    &#125;)(i)&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在 JQuery/Node 的插件和模块开发中，为避免变量污染，也是一个大大的 IIFE：</p>
<p>(function($) {<br>        //代码<br> } )(jQuery);</p>
<p>5、在严格模式(‘use strict’)下进行 JavaScript 开发有神马好处？</p>
<ul>
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的Javascript做好铺垫。</li>
</ul>
<p>6、下面两个函数的返回值是一样的吗？为什么？<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo1()&#10;&#123;&#10;  return &#123;&#10;      bar: &#34;hello&#34;&#10;  &#125;;&#10;&#125;&#10;&#10;function foo2()&#10;&#123;&#10;  return&#10;  &#123;&#10;      bar: &#34;hello&#34;&#10;  &#125;;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在编程语言中，基本都是使用分号（;）将语句分隔开，这可以增加代码的可读性和整洁性。而在JS中，如若语句各占独立一行，通常可以省略语句间的分号（;），JS 解析器会根据能否正常编译来决定是否自动填充分号：<br>var test = 1 + 2<br>console.log(test);  //3</p>
<p>在上述情况下，为了正确解析代码，就不会自动填充分号了，但是对于 return 、break、continue 等语句，如果后面紧跟换行，解析器一定会自动在后面填充分号(;)，所以上面的第二个函数就变成了这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo2()&#10;&#123;&#10;  return;&#10;  &#123;&#10;      bar: &#34;hello&#34;&#10;  &#125;;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>所以第二个函数是返回 undefined。</p>
<p>7、神马是 NaN，它的类型是神马？怎么测试一个值是否等于 NaN?<br>NaN 是 Not a Number 的缩写，JavaScript 的一种特殊数值，其类型是 Number，可以通过 isNaN(param) 来判断一个值是否是 NaN：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(isNaN(NaN)); &#10;//true&#10;console.log(isNaN(23)); &#10;//false&#10;console.log(isNaN(&#39;ds&#39;)); &#10;//true&#10;console.log(isNaN(&#39;32131sdasd&#39;)); &#10;//true&#10;console.log(NaN === NaN); &#10;//false&#10;console.log(NaN === undefined); &#10;//false&#10;console.log(undefined === undefined); &#10;//falseconsole.log(typeof NaN); &#10;//number&#10;console.log(Object.prototype.toString.call(NaN));&#10;//[object Number]&#10;ES6 &#20013;&#65292;isNaN() &#25104;&#20026;&#20102; Number &#30340;&#38745;&#24577;&#26041;&#27861;&#65306;Number.isNaN().&#10;&#10;&#10;8&#12289;&#35299;&#37322;&#19968;&#19979;&#19979;&#38754;&#20195;&#30721;&#30340;&#36755;&#20986;&#10;console.log(0.1 + 0.2);   //0.30000000000000004&#10;console.log(0.1 + 0.2 == 0.3);  //false&#10;JavaScript &#20013;&#30340; number &#31867;&#22411;&#23601;&#26159;&#28014;&#28857;&#22411;&#65292;JavaScript &#20013;&#30340;&#28014;&#28857;&#25968;&#37319;&#29992;IEEE-754 &#26684;&#24335;&#30340;&#35268;&#23450;&#65292;&#36825;&#26159;&#19968;&#31181;&#20108;&#36827;&#21046;&#34920;&#31034;&#27861;&#65292;&#21487;&#20197;&#31934;&#30830;&#22320;&#34920;&#31034;&#20998;&#25968;&#65292;&#27604;&#22914;1/2&#65292;1/8&#65292;1/1024&#65292;&#27599;&#20010;&#28014;&#28857;&#25968;&#21344;64&#20301;&#12290;&#20294;&#26159;&#65292;&#20108;&#36827;&#21046;&#28014;&#28857;&#25968;&#34920;&#31034;&#27861;&#24182;&#19981;&#33021;&#31934;&#30830;&#30340;&#34920;&#31034;&#31867;&#20284;0.1&#36825;&#26679; &#30340;&#31616;&#21333;&#30340;&#25968;&#23383;&#65292;&#20250;&#26377;&#33293;&#20837;&#35823;&#24046;&#12290;&#10;&#30001;&#20110;&#37319;&#29992;&#20108;&#36827;&#21046;&#65292;JavaScript &#20063;&#19981;&#33021;&#26377;&#38480;&#34920;&#31034; 1/10&#12289;1/2 &#31561;&#36825;&#26679;&#30340;&#20998;&#25968;&#12290;&#22312;&#20108;&#36827;&#21046;&#20013;&#65292;1/10(0.1)&#34987;&#34920;&#31034;&#20026;0.00110011001100110011&#8230;&#8230; &#27880;&#24847; 0011 &#26159;&#26080;&#38480;&#37325;&#22797;&#30340;&#65292;&#36825;&#26159;&#33293;&#20837;&#35823;&#24046;&#36896;&#25104;&#30340;&#65292;&#25152;&#20197;&#23545;&#20110; 0.1 + 0.2 &#36825;&#26679;&#30340;&#36816;&#31639;&#65292;&#25805;&#20316;&#25968;&#20250;&#20808;&#34987;&#36716;&#25104;&#20108;&#36827;&#21046;&#65292;&#28982;&#21518;&#20877;&#35745;&#31639;&#65306;&#10;0.1 =&#62; 0.0001 1001 1001 1001&#8230;&#65288;&#26080;&#38480;&#24490;&#29615;&#65289;&#10;0.2 =&#62; 0.0011 0011 0011 0011&#8230;&#65288;&#26080;&#38480;&#24490;&#29615;&#65289;&#10;&#10;&#21452;&#31934;&#24230;&#28014;&#28857;&#25968;&#30340;&#23567;&#25968;&#37096;&#20998;&#26368;&#22810;&#25903;&#25345; 52 &#20301;&#65292;&#25152;&#20197;&#20004;&#32773;&#30456;&#21152;&#20043;&#21518;&#24471;&#21040;&#36825;&#20040;&#19968;&#20018; 0.0100110011001100110011001100110011001100&#8230;&#22240;&#28014;&#28857;&#25968;&#23567;&#25968;&#20301;&#30340;&#38480;&#21046;&#32780;&#25130;&#26029;&#30340;&#20108;&#36827;&#21046;&#25968;&#23383;&#65292;&#36825;&#26102;&#20505;&#65292;&#20877;&#25226;&#23427;&#36716;&#25442;&#20026;&#21313;&#36827;&#21046;&#65292;&#23601;&#25104;&#20102; 0.30000000000000004&#12290;&#10;&#23545;&#20110;&#20445;&#35777;&#28014;&#28857;&#25968;&#35745;&#31639;&#30340;&#27491;&#30830;&#24615;&#65292;&#26377;&#20004;&#31181;&#24120;&#35265;&#26041;&#24335;&#12290;&#10;&#19968;&#26159;&#20808;&#21319;&#24130;&#20877;&#38477;&#24130;&#65306;&#10;&#10;```dash&#10;function add(num1, num2)&#123;&#10;  let r1, r2, m;&#10;  r1 = (&#39;&#39;+num1).split(&#39;.&#39;)[1].length;&#10;  r2 = (&#39;&#39;+num2).split(&#39;.&#39;)[1].length;&#10;&#10;  m = Math.pow(10,Math.max(r1,r2));&#10;  return (num1 * m + num2 * m) / m;&#10;&#125;&#10;console.log(add(0.1,0.2));   &#10;//0.3&#10;console.log(add(0.15,0.2256)); &#10;//0.3756</span><br></pre></td></tr></table></figure>
<p>二是是使用内置的 toPrecision() 和 toFixed() 方法，注意，方法的返回值字符串。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;&#10;    return x.toPrecision() + y.toPrecision()&#10;&#125;&#10;console.log(add(0.1,0.2));  //&#34;0.10.2&#34;</span><br></pre></td></tr></table></figure>
<p>9、实现函数 isInteger(x) 来判断 x 是否是整数<br>可以将 x 转换成10进制，判断和本身是不是相等即可：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function isInteger(x) &#123; &#10;    return parseInt(x, 10) === x; &#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES6 对数值进行了扩展，提供了静态方法 isInteger() 来判断参数是否是整数：</p>
<p>Number.isInteger(25) /<br>/ true<br>Number.isInteger(25.0)<br>// true<br>Number.isInteger(25.1)<br>// false<br>Number.isInteger(“15”)<br>// false<br>Number.isInteger(true)<br>// false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;JavaScript&#33021;&#22815;&#20934;&#30830;&#34920;&#31034;&#30340;&#25972;&#25968;&#33539;&#22260;&#22312; -2^53 &#21040; 2^53 &#20043;&#38388;&#65288;&#19981;&#21547;&#20004;&#20010;&#31471;&#28857;&#65289;&#65292;&#36229;&#36807;&#36825;&#20010;&#33539;&#22260;&#65292;&#26080;&#27861;&#31934;&#30830;&#34920;&#31034;&#36825;&#20010;&#20540;&#12290;ES6 &#24341;&#20837;&#20102;Number.MAX_SAFE_INTEGER &#21644; Number.MIN_SAFE_INTEGER&#36825;&#20004;&#20010;&#24120;&#37327;&#65292;&#29992;&#26469;&#34920;&#31034;&#36825;&#20010;&#33539;&#22260;&#30340;&#19978;&#19979;&#38480;&#65292;&#24182;&#25552;&#20379;&#20102; Number.isSafeInteger() &#26469;&#21028;&#26029;&#25972;&#25968;&#26159;&#21542;&#26159;&#23433;&#20840;&#22411;&#25972;&#25968;&#12290;&#10;&#10;&#10;&#10;10&#12289;&#22312;&#19979;&#38754;&#30340;&#20195;&#30721;&#20013;&#65292;&#25968;&#23383; 1-4 &#20250;&#20197;&#20160;&#20040;&#39034;&#24207;&#36755;&#20986;&#65311;&#20026;&#20160;&#20040;&#20250;&#36825;&#26679;&#36755;&#20986;&#65311;&#10;```dash&#10;(function() &#123;&#10;    console.log(1); &#10;    setTimeout(function()&#123;console.log(2)&#125;, 1000); &#10;    setTimeout(function()&#123;console.log(3)&#125;, 0); &#10;    console.log(4);&#10;&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>这个就不多解释了，主要是 JavaScript 的定时机制和时间循环，不要忘了，JavaScript 是单线程的。详解可以参考 从setTimeout谈JavaScript运行机制。</p>
<p>11、写一个少于 80 字符的函数，判断一个字符串是不是回文字符串<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function isPalindrome(str) &#123;&#10;    str = str.replace(/\W/g, &#39;&#39;).toLowerCase();&#10;    return (str == str.split(&#39;&#39;).reverse().join(&#39;&#39;));&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>12、写一个按照下面方式调用都能正常工作的 sum 方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(sum(2,3));   // Outputs 5&#10;console.log(sum(2)(3));  // Outputs 5&#10;&#10;function sum() &#123;&#10;  var fir = arguments[0];&#10;  if(arguments.length === 2) &#123;&#10;    return arguments[0] + arguments[1]&#10;  &#125; else &#123;&#10;    return function(sec) &#123;&#10;       return fir + sec;&#10;    &#125;&#10;  &#125;&#10;   &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>13、根据下面的代码片段回答后面的问题<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &#60; 5; i++) &#123;&#10;  var btn = document.createElement(&#39;button&#39;);&#10;  btn.appendChild(document.createTextNode(&#39;Button &#39; + i));&#10;  btn.addEventListener(&#39;click&#39;, function()&#123; console.log(i); &#125;);&#10;  document.body.appendChild(btn);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>1、点击 Button 4，会在控制台输出什么？<br>2、给出一种符合预期的实现方式<br>1、点击5个按钮中的任意一个，都是输出5<br>2、参考 IIFE。</p>
<p>14、下面的代码会输出什么？为什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = &#34;john&#34;.split(&#39;&#39;); j o h n&#10;var arr2 = arr1.reverse(); n h o j&#10;var arr3 = &#34;jones&#34;.split(&#39;&#39;); j o n e s&#10;arr2.push(arr3);&#10;console.log(&#34;array 1: length=&#34; + arr1.length + &#34; last=&#34; + arr1.slice(-1));&#10;console.log(&#34;array 2: length=&#34; + arr2.length + &#34; last=&#34; + arr2.slice(-1));</span><br></pre></td></tr></table></figure>
<p>会输出什么呢？你运行下就知道了，可能会在你的意料之外。<br>reverse() 会改变数组本身，并返回原数组的引用。<br>slice 的用法请参考：slice</p>
<p>15、下面的代码会输出什么？为什么？<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(1 +  &#34;2&#34; + &#34;2&#34;);&#10;console.log(1 +  +&#34;2&#34; + &#34;2&#34;);&#10;console.log(1 +  -&#34;1&#34; + &#34;2&#34;);&#10;console.log(+&#34;1&#34; +  &#34;1&#34; + &#34;2&#34;);&#10;console.log( &#34;A&#34; - &#34;B&#34; + &#34;2&#34;);&#10;console.log( &#34;A&#34; - &#34;B&#34; + 2);</span><br></pre></td></tr></table></figure></p>
<p>输出什么，自己去运行吧，需要注意三个点：</p>
<ul>
<li>多个数字和数字字符串混合运算时，跟操作数的位置有关</li>
</ul>
<p>console.log(2 + 1 + ‘3’); / /‘33’<br>console.log(‘3’ + 2 + 1); //‘321’</p>
<ul>
<li>数字字符串之前存在数字中的正负号(+/-)时，会被转换成数字</li>
</ul>
<p>console.log(typeof ‘3’);   // stringconsole.log(typeof +’3’);  //number<br>同样，可以在数字前添加 ‘’，将数字转为字符串<br>console.log(typeof 3);   // numberconsole.log(typeof (‘’+3));  //string</p>
<ul>
<li>对于运算结果不能转换成数字的，将返回 NaN</li>
</ul>
<p>console.log(‘a’ * ‘sd’);   //NaNconsole.log(‘A’ - ‘B’);  // NaN<br>这张图是运算转换的规则</p>
<p>16、如果 list 很大，下面的这段递归代码会造成堆栈溢出。如果在不改变递归模式的前提下修善这段代码？<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var list = readHugeList();&#10;var nextListItem = function() &#123;&#10;    var item = list.pop();&#10;&#10;    if (item) &#123;&#10;        // process the list item...&#10;        nextListItem();&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>原文上的解决方式是加个定时器：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var list = readHugeList();&#10;var nextListItem = function() &#123;&#10;    var item = list.pop();&#10;&#10;    if (item) &#123;&#10;        // process the list item...&#10;        setTimeout( nextListItem, 0);&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>17、什么是闭包？举例说明<br>可以参考此篇：从作用域链谈闭包</p>
<p>18、下面的代码会输出什么？为啥？<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &#60; 5; i++) &#123;&#10;  setTimeout(function() &#123; console.log(i); &#125;, i * 1000 );&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>请往前面翻，参考第4题，解决方式已经在上面了</p>
<p>19、解释下列代码的输出<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#34;0 || 1 = &#34;+(0 || 1));&#10;console.log(&#34;1 || 2 = &#34;+(1 || 2));&#10;console.log(&#34;0 &#38;&#38; 1 = &#34;+(0 &#38;&#38; 1));&#10;console.log(&#34;1 &#38;&#38; 2 = &#34;+(1 &#38;&#38; 2));</span><br></pre></td></tr></table></figure></p>
<p>逻辑与和逻辑或运算符会返回一个值，并且二者都是短路运算符：</p>
<ul>
<li>逻辑与返回第一个是 false 的操作数 或者 最后一个是 true的操作数</li>
</ul>
<p>console.log(1 &amp;&amp; 2 &amp;&amp; 0);  //0<br>console.log(1 &amp;&amp; 0 &amp;&amp; 1);  //0<br>console.log(1 &amp;&amp; 2 &amp;&amp; 3);  //3<br>如果某个操作数为 false，则该操作数之后的操作数都不会被计算</p>
<ul>
<li>逻辑或返回第一个是 true 的操作数 或者 最后一个是 false的操作数</li>
</ul>
<p>console.log(1 || 2 || 0); //1<br>console.log(0 || 2 || 1); //2<br>console.log(0 || 0 || false); //false</p>
<p>如果某个操作数为 true，则该操作数之后的操作数都不会被计算<br>如果逻辑与和逻辑或作混合运算，则逻辑与的优先级高：</p>
<p>console.log(1 &amp;&amp; 2 || 0); //2<br>console.log(0 || 2 &amp;&amp; 1); //1<br>console.log(0 &amp;&amp; 2 || 1); //1</p>
<p>在 JavaScript，常见的 false 值：<br>0, ‘0’, +0, -0, false, ‘’,null,undefined,null,NaN</p>
<p>要注意空数组([])和空对象({}):<br>console.log([] == false) //trueconsole.log({} == false) //falseconsole.log(Boolean([])) //trueconsole.log(Boolean({})) //true</p>
<p>所以在 if 中，[] 和 {} 都表现为 true：</p>
<p>20、解释下面代码的输出<br>console.log(false == ‘0’)<br>console.log(false === ‘0’)</p>
<p>21、解释下面代码的输出<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a=&#123;&#125;,&#10;    b=&#123;key:&#39;b&#39;&#125;,&#10;    c=&#123;key:&#39;c&#39;&#125;;&#10;&#10;a[b]=123;&#10;a[c]=456;&#10;&#10;console.log(a[b]);</span><br></pre></td></tr></table></figure></p>
<p>输出是 456</p>
<p>22、解释下面代码的输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log((function f(n)&#123;return ((n &#62; 1) ? n * f(n-1) : n)&#125;)(10));</span><br></pre></td></tr></table></figure>
<p>结果是10的阶乘。这是一个递归调用，为了简化，我初始化 n=5，则调用链和返回链如下：</p>
<p>23、解释下面代码的输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function(x) &#123;&#10;    return (function(y) &#123;&#10;        console.log(x);&#10;    &#125;)(2)&#10;&#125;)(1);</span><br></pre></td></tr></table></figure>
<p>输出1，闭包能够访问外部作用域的变量或参数。</p>
<p>24、解释下面代码的输出，并修复存在的问题<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var hero = &#123;&#10;    _name: &#39;John Doe&#39;,&#10;    getSecretIdentity: function ()&#123;&#10;        return this._name;&#10;    &#125;&#10;&#125;;&#10;var stoleSecretIdentity = hero.getSecretIdentity;&#10;console.log(stoleSecretIdentity());&#10;console.log(hero.getSecretIdentity());</span><br></pre></td></tr></table></figure></p>
<p>将 getSecretIdentity 赋给 stoleSecretIdentity，等价于定义了 stoleSecretIdentity 函数：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var stoleSecretIdentity =  function ()&#123;&#10;        return this._name;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>stoleSecretIdentity 的上下文是全局环境，所以第一个输出 undefined。若要输出 John Doe，则要通过 call、apply 和 bind 等方式改变 stoleSecretIdentity 的this 指向(hero)。<br>第二个是调用对象的方法，输出 John Doe。</p>
<p>25、给你一个 DOM 元素，创建一个能访问该元素所有子元素的函数，并且要将每个子元素传递给指定的回调函数。<br>函数接受两个参数：</p>
<ul>
<li>DOM</li>
<li>指定的回调函数</li>
</ul>
<p>原文利用 深度优先搜索(Depth-First-Search) 给了一个实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Traverse(p_element,p_callback) &#123;&#10;   p_callback(p_element);&#10;   var list = p_element.children;&#10;   for (var i = 0; i &#60; list.length; i++) &#123;&#10;       Traverse(list[i],p_callback);  // recursive call&#10;   &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/03/29/单例/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          单例
        
      </div>
    </a>
  
  
    <a href="/2016/03/25/函数编程/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">函数编程</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>








</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div>&copy; 2016 任先生在路上 的博客 , 技术 
        <a href="http://hexo.io/" target="_blank">Hexo</a>  
      </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>