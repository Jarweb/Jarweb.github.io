<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>再看this | Jar-R</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我们会这样写「李华正在飞快地跑着，因为他正在赶火车。」注意这里代词「他」的用法。我们也可以这样写：「李华正在飞快地跑着，因为李华正在赶火车。」我们通常不会把「李华」这个名字像这样重复使用，因为这样显得很神经。类似地，在 JavaScript 中，我们使用 this 作为一种指代。它指代一个对象（object），也就是那个上下文中的主语，或者说运行时的主体。考虑下面这个例子：
1var person">
<meta property="og:type" content="article">
<meta property="og:title" content="再看this">
<meta property="og:url" content="http://Jarweb.com/2016/01/14/再看this/index.html">
<meta property="og:site_name" content="Jar-R">
<meta property="og:description" content="我们会这样写「李华正在飞快地跑着，因为他正在赶火车。」注意这里代词「他」的用法。我们也可以这样写：「李华正在飞快地跑着，因为李华正在赶火车。」我们通常不会把「李华」这个名字像这样重复使用，因为这样显得很神经。类似地，在 JavaScript 中，我们使用 this 作为一种指代。它指代一个对象（object），也就是那个上下文中的主语，或者说运行时的主体。考虑下面这个例子：
1var person">
<meta property="og:updated_time" content="2016-05-23T17:57:34.045Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="再看this">
<meta name="twitter:description" content="我们会这样写「李华正在飞快地跑着，因为他正在赶火车。」注意这里代词「他」的用法。我们也可以这样写：「李华正在飞快地跑着，因为李华正在赶火车。」我们通常不会把「李华」这个名字像这样重复使用，因为这样显得很神经。类似地，在 JavaScript 中，我们使用 this 作为一种指代。它指代一个对象（object），也就是那个上下文中的主语，或者说运行时的主体。考虑下面这个例子：
1var person">
  
    <link rel="alternative" href="/atom.xml" title="Jar-R" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">任先生在路上</a></h1>
		</hgroup>

		
		<p class="header-subtitle" style="margin-bottom:20px;">Good things are coming !</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger" style="display:none;"></div>
  		<h1 class="header-author js-mobile-header hide">任先生在路上</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">任先生在路上</h1>
			</hgroup>
			
			<p class="header-subtitle">Good things are coming !</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-再看this" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/14/再看this/" class="article-date">
  	<time datetime="2016-01-13T16:00:00.000Z" itemprop="datePublished">2016-01-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      再看this
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js原生/">js原生</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们会这样写「李华正在飞快地跑着，因为他正在赶火车。」注意这里代词「他」的用法。我们也可以这样写：「李华正在飞快地跑着，因为李华正在赶火车。」我们通常不会把「李华」这个名字像这样重复使用，因为这样显得很神经。类似地，在 JavaScript 中，我们使用 this 作为一种指代。它指代一个对象（object），也就是那个上下文中的主语，或者说运行时的主体。考虑下面这个例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123; &#10;&#9;firstName: &#34;Penelope&#34;, &#10;&#9;lastName: &#34;Barrymore&#34;, &#10;&#9;fullName: function () &#123; &#10;&#9;// &#27880;&#24847;&#25105;&#20204;&#20351;&#29992;&#12300;this&#12301;&#20851;&#38190;&#23383;&#23601;&#20687;&#25105;&#20204;&#22312;&#19978;&#25991;&#20013;&#20351;&#29992;&#12300;&#20182;&#12301;&#19968;&#26679; &#10;&#9;console.log(this.firstName + &#34; &#34; + this.lastName); &#10;&#9;// &#25105;&#20204;&#20063;&#21487;&#20197;&#36825;&#26679;&#20889; &#10;&#9;console.log(person.firstName + &#34; &#34; + person.lastName); &#125; &#10;&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果我们使用 person.firstName 和 person.lastName 这种写法的话，我们的代码就会变得有歧义。假设有一个全局变量（我们或许有意为之，或许根本没有意识到）的名字也叫 person ，那么 person.firstName 将会尝试读取那个全局变量 person 中的 firstName 属性，这将可能导致极难调试的错误。所以我们使用 this 关键字，不仅仅是因为这看起来十分优雅，还因为这样使用更加准确。使用 this 消除了我们代码中的歧义，就像在上文中使用「他」让我们的话显得更加清晰一样。它让我们明白我们想要指代的李华就是句子刚开头提到的那个李华。<br>就像代词「他」用来指代之前提到的人一样，this 这个关键字也是用来指代那个被当前函数（就是使用了 this 的函数）绑定的对象。</p>
<p>this 这个关键字不仅仅是指代那个对象，并且包含了那个对象的值。这很类似代词，this 可以被视作是指代「上下文」中对象（也称为「祖先对象」）的一种便捷的方式（同时也是一种没有歧义的替换）。我们将在后面学习更多关于「上下文」 的概念。<br>JavaScript this 用法基础首先，我们已经知道在 JavaScript 中，函数和对象一样都有属性。而当一个函数执行的时候，它就获得了 this 这个属性。而 this 其实就是一个具有调用当前函数的对象的值的变量。</p>
<p>this 这个变量 永远 指向 一个 对象，并且拥有这个对象的值。虽然 this 可以在全局作用域中出现，但它通常还是会在函数体内或对象的方法内。有一点要注意的是，当我们使用严格模式（strict mode）的时候，this 在全局函数中和匿名函数中的值是未定义的（undefined），不指向任何一个对象。<br>this 在一个函数体内出现的时候（设为函数 A ），它包含了调用函数 A 的那个对象的值。我们需要使用 this 来读取调用函数 A 的那个对象的方法或是属性。而这在我们不知道那个对象的名字，甚至有时候那个对象没有名字的情况下就变得尤为重要。实际上，this 真的仅仅就是对「祖先对象」，或者说调用这个函数的那个对象，的一个便捷的指代而已。<br>我们用一个例子来展示 JavaScript 中 this 的一些基本用法，也来回顾一下上文的内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123; &#10;firstName: &#34;Penelope&#34;, &#10;lastName: &#34;Barrymore&#34;, &#10;// &#22240;&#20026; this &#20851;&#38190;&#23383;&#22312; showFullName &#26041;&#27861;&#20013;&#34987;&#29992;&#21040;&#65292;&#32780; showFullName &#22312; person &#36825;&#20010;&#23545;&#35937;&#20013;&#34987;&#23450;&#20041;&#65292; &#10;// &#25152;&#20197; this &#23558;&#20250;&#20855;&#26377; person &#36825;&#20010;&#23545;&#35937;&#30340;&#20540;&#65292;&#22240;&#20026; person &#23545;&#35937;&#23558;&#20250;&#35843;&#29992; showFullName() showFullName: function() &#123; &#10;&#9;console.log (this.firstName + &#34; &#34; + this.lastName); &#125; &#10;&#125;  &#10;person.showFullName(); &#10;// Penelope Barrymore</span><br></pre></td></tr></table></figure>
<p>再来看看 jQuery 中 this 用法的例子：<br>// 一段非常普遍的 jQuery 代码<br>$ (“button”).click (function (event) {<br>// $(this) 将具有那个 ($(“button”)) 按钮对象的值<br>// 因为那个按钮对象调用了 click() 方法<br>console.log ($(this).prop(“name”)); }); </p>
<p>我来解释一下上面的这个 jQuery 示例：$(this) 是 jQuery 中与 JavaScript 中this 类同的语法，它被用在一个匿名函数中，而这个匿名函数在一个按钮的click() 方法中被执行。$(this) 之所以具有这个按钮对象的值是因为 jQuery 库把 $(this) 和那个调用了 click 方法的对象手动 绑定 （bind）在一起了。 因此，即使 $(this) 是在一个匿名函数中被定义，并且自身不能读取外部函数中的 this 变量，它仍然能够具有那个 jQuery 按钮对象 ($(“button”)) 的值。<br>注意，按钮（button）是一个 HTML 页面上的 DOM 元素，同时也是一个对象；在上面这个例子中的按钮是一个 jQuery 对象，因为我们把它包装在 jQuery 的$() 函数中了。</p>
<p>理解 JavaScript this 的关键如果你理解了 JavaScript this 的以下这个原则的话，那你对 this 这个关键字就会有一个清晰的认识了：只有一个对象调用了包含 this 的函数的时候，this 才会被赋值。我们不妨把包含 this 的函数称作 this 函数。<br>在一个对象方法中定义的 this 看起来好像指向了这个对象本身，但仍然只有在某个对象调用了这个 this 函数 的时候它才被赋值。并且被赋的那个值 只依赖于调用了 this 函数 的那个对象。虽然在大多数情况下， this 都是那个调用了this 函数 的那个对象，但也有一些情况不是这样的。我将会在后文中讲到这一点。<br>在全局作用域中使用 this在全局作用域中，当代码在浏览器中执行的时候，所有的全局变量和函数都被定义在 window 对象上。因此，当我们在全局函数中使用 this 的时候，它会指向全局 window 对象并且拥有它的值（除非在严格模式下），此时的 this 就成了整个 JavaScript 应用程序或者说整个网页的主容器。<br>所以：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var firstName = &#34;Peter&#34;, lastName = &#34;Ally&#34;;  &#10;function showFullName () &#123; &#10;// &#22312;&#36825;&#20010;&#20989;&#25968;&#20013;&#65292;this &#23558;&#20250;&#25317;&#26377; window &#23545;&#35937;&#30340;&#20540; &#10;// &#22240;&#20026; showFullName() &#20989;&#25968;&#65292;&#21644; firstName, lastName &#19968;&#26679;&#26159;&#23450;&#20041;&#22312;&#20840;&#23616;&#20316;&#29992;&#22495;&#30340; &#10;console.log (this.firstName + &#34; &#34; + this.lastName); &#125; &#10;var person = &#123; firstName: &#34;Penelope&#34;, lastName: &#34;Barrymore&#34;, &#10;showFullName:function () &#123; &#10;// &#19979;&#38754;&#36825;&#34892;&#20013;&#30340; this &#25351;&#20195; person &#23545;&#35937;&#65292;&#22240;&#20026; showFullName &#36825;&#20010;&#20989;&#25968;&#23558;&#20250;&#34987; person &#23545;&#35937;&#35843;&#29992; console.log (this.firstName + &#34; &#34; + this.lastName); &#125; &#125;  &#10;showFullName (); &#10;// Peter Ally  &#10;// &#25152;&#26377;&#30340;&#20840;&#23616;&#21464;&#37327;&#21644;&#20989;&#25968;&#37117;&#23450;&#20041;&#22312; window &#23545;&#35937;&#19978;&#38754;&#65292;&#25152;&#20197;&#65306; &#10;window.showFullName (); &#10;// Peter Ally &#10;// &#22312; person &#23545;&#35937;&#20013;&#23450;&#20041;&#30340; showFullName() &#20989;&#25968;&#20013;&#30340; this &#20173;&#28982;&#25351;&#21521; person &#23545;&#35937;&#65292;&#25152;&#20197;&#65306; person.showFullName (); &#10;// Penelope Barrymore</span><br></pre></td></tr></table></figure>
<p>this 最容易被误解和难以掌握的情景this 关键字在以下场景中常常被误解：当我们借用一个使用了 this 的方法的时候；当我们把一个只用了 this 的方法赋给一个变量的时候；当一个使用了this 的方法被当作回调函数传入的时候；当 this 在闭包中使用的时候。我们能过举例来详细地解释在上面的每一种情形中如何使 this 拥有合适的值。<br>一点重要的提示</p>
<p>在接下去讲之前，我们先来谈谈「上下文」（Context）这个概念<br>在 JavaScript 中，上下文的概念和一个英文句子中主语的概念相类似：「John is the winner who returned the money.」这句话中的主语是 John ，我们可以说这句话的语境（上下文）是 John ，因为这句话此时的关注点在 John 身上。代词「who」也是指代先行词 John。正如我们可以使用分号来切换句子的主语一样，我们可以通过让另一个对象去调用本对象的方法的方式来切换上下文。<br>用代码可以这样描述</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123; &#10;firstName: &#34;Penelope&#34;, &#10;lastName: &#34;Barrymore&#34;, &#10;showFullName: function() &#123; &#10;// &#12300;&#19978;&#19979;&#25991;&#12301; &#10;console.log(this.firstName + &#34; &#34; + this.lastName); &#125; &#125; &#10;// &#24403;&#25105;&#20204;&#22312; person &#23545;&#35937;&#19978;&#35843;&#29992; showFullName() &#26041;&#27861;&#30340;&#26102;&#20505;&#65292;&#12300;&#19978;&#19979;&#25991;&#12301;&#26159; persion &#23545;&#35937;&#12290; &#10;// &#36825;&#26102;&#22312; showFullName() &#26041;&#27861;&#37324;&#38754;&#20351;&#29992;&#30340; this &#23601;&#25317;&#26377;&#20102; person &#23545;&#35937;&#30340;&#20540; person.showFullName(); // Penelope Barrymore &#10;// &#24403;&#25105;&#20204;&#20351;&#29992;&#21478;&#19968;&#20010;&#23545;&#35937;&#26469;&#35843;&#29992; showFullName &#30340;&#26102;&#20505; var anotherPerson = &#123; firstName: &#34;Rohit&#34;, lastName: &#34;Khan&#34; &#125;; &#10;// &#25105;&#20204;&#21487;&#20197;&#20351;&#29992; apply &#26041;&#27861;&#26469;&#26174;&#24335;&#22320;&#35774;&#32622; this &#30340;&#20540;&#12290;&#20851;&#20110; apply() &#26041;&#27861;&#65292;&#25105;&#20204;&#23558;&#22312;&#21518;&#25991;&#20013;&#35814;&#32454;&#35299;&#37322; // this &#24471;&#21040;&#30340;&#27704;&#36828;&#26159;&#35843;&#29992;&#23427;&#30340;&#37027;&#20010;&#23545;&#35937;&#30340;&#20540;&#65292;&#22240;&#27492;&#65306; person.showFullName.apply(anotherPerson); // Rohit Khan &#10;// &#25152;&#20197;&#29616;&#22312;&#19978;&#19979;&#25991;&#23601;&#21464;&#25104;&#20102; anotherPerson &#65292;&#22240;&#20026;&#26159; anotherPerson &#20351;&#29992; apply() &#26041;&#27861;&#35843;&#29992;&#20102; person.showFullName() &#26041;&#27861;</span><br></pre></td></tr></table></figure>
<p>在下面这些情景中，this 关键字可能会变得十分难以理解。我们在示例中同时给出了解决有关 this 使用错误的方案。</p>
<ol>
<li>解决当包含 this 的方法被当做回调函数时遇到的问题当我们把含有 this 的方法当做回调函数的时候代码往往变得十分难以理解。比如：<br>// 我们有一个简单的对象，它有一个 clickHandler 方法，我们想要使当页面上的一个按钮被点击时它被调用 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123; data: [ &#123;name: &#34;T. Woods&#34;, age: 37&#125;, &#123;name: &#34;P. Mickelson&#34;, age: 43&#125; ], clickHandler: function(event) &#123; &#10;var randomNum = ((Math.random() * 2 | 0) + 1) - 1; &#10;// &#20135;&#29983; 0 &#21040; 1 &#20043;&#38388;&#30340;&#38543;&#26426;&#25968; &#10;// &#19979;&#38754;&#36825;&#34892;&#20250;&#38543;&#26426;&#25171;&#21360;&#20986;&#19968;&#20010; data &#25968;&#32452;&#20013;&#30340;&#20154;&#30340;&#22995;&#21517;&#21644;&#24180;&#40836;  &#10;console.log(this.data[randomNum].name + &#34; &#34; + this.data[randomNum].age); &#125; &#125; &#10;// &#36825;&#20010; button &#34987; jQuery &#30340; $ &#21253;&#35013;&#36215;&#26469;&#20102;&#65292;&#25152;&#20197;&#23427;&#21464;&#25104;&#20102;&#19968;&#20010; jQuery &#23545;&#35937; &#10;// &#19979;&#38754;&#36825;&#34892;&#20250;&#36755;&#20986; undefined &#22240;&#20026; button &#23545;&#35937;&#27809;&#26377; data &#23646;&#24615; &#10;$(&#34;button&#34;).click(user.clickHandler);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在上面的代码中，按钮 ($(“button”)) 是一个对象，我们把user.clickHandler 传入它的 click() 方法作为一个回调函数，这时候我们就明白 user.clickHandler 方法里面的 this 已经不再指向 user 这个对象了。因为 this 是定义在 user.clickHandler 方法里的，所以它现在指向那个调用了 user.clickHandler 的对象。而那个对象就是 button 对象。也就是说，user.clickHandler 将会在 button 对象的 click 方法中被执行。<br>注意在调用 clickHandler() 时，我们虽然写成了 user.clickHander 的形式（事实上我们必须这么写，因为 clickHandler 是在 user 对象中被定义的），但 clickHandler 还会在 button 对象的上下文中被执行，this 也因而指向了 button 对象。<br>讲到这里，我们应该发现当上下文发生变化的时候，换句话说就是当我们在别的对象中调用了本对象内定义的方法的时候，this 关键字就不再指向定义 this 时的那个对象了，而是指向了调用了那个 this 所在方法的对象。<br>解决 this 方法被当作回调函数传递时指向错误的方法：<br>因为我们确实想要让 this.data 指向 user 对象的 data 属性，我们可以使用bind(), apply(), call() 这三个方法来显式地设置 this 的值。<br>我还写了另一篇文章，Javascript 进阶：Apply, Call 和 Bind 方法详解 来详细解释这三种方法的用法，包括如何使用它们在各种容易出错情景下正确地设置 this的值。我就不在这里贴出整篇文章了，推荐读者详细地阅读整篇文章，因为我认为要想成为 JavaScript 的高级开发者，和这三种方法打交道是不可避免的。<br>为了解决上面例子提到的那种问题，我们可以使用 bind 方法：<br>我们把下面这行：<br>$(“button”).click(user.clickHandler); </p>
<p>改正为下面这样，把 clickHandler 和 user 绑定起来：<br>$(“button”).click(user.clickHandler.bind(user)); </p>
<ol>
<li>解决当 this 出现在闭包内遇到的问题另一个 this 常常被误解的情景是当我们使用闭包的时候。一个非常值得注意的地方是，闭包不能直接通过使用 this 来访问外层函数的 this 变量，因为this 变量只有当前函数本身可以访问，而其内层函数是访问不到的。举个例子：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123; tournament: &#34;The Masters&#34;, data: [ &#123;name: &#34;T. Woods&#34;, age: 37&#125;, &#123;name: &#34;P. Mickelson&#34;, age: 43&#125; ], &#10;clickHandler: function() &#123; &#10;// &#22312;&#36825;&#37324;&#20351;&#29992; this.data &#26159;&#21487;&#20197;&#30340;&#65292;&#22240;&#20026; this &#25351;&#21521; user &#23545;&#35937;&#65292;&#32780; data &#26159; user &#23545;&#35937;&#30340;&#19968;&#20010;&#23646;&#24615; this.data.forEach(function(person)) &#123; &#10;// &#20294;&#26159;&#22312;&#20869;&#23618;&#21311;&#21517;&#20989;&#25968;&#20013;&#65288;&#23601;&#26159;&#25105;&#20204;&#20256;&#32473; forEach &#26041;&#27861;&#30340;&#20989;&#25968;&#65289;&#65292;this &#19981;&#20877;&#25351;&#21521; user &#23545;&#35937;&#20102; &#10;// &#36825;&#20010;&#20869;&#23618;&#20989;&#25968;&#19981;&#33021;&#35775;&#38382;&#22806;&#23618;&#20989;&#25968;&#30340; this &#21464;&#37327;&#20102; &#10;console.log(&#34;What is This referring to? &#34; + this); &#10;//[Object Window] &#10;console.log(person.name + &#34; is playing at &#34; + this.tournament); &#10;// T. Woods is playing at undefined &#10;// P. Mickelson is playing at undefined &#125;); &#125; &#125; user.clickHandler(); &#10;// &#29616;&#22312; this &#25351;&#21521;&#20160;&#20040;&#65311;[object Window]</span><br></pre></td></tr></table></figure>
<p>在匿名函数内部的 this 不能获得外层函数 this 的值，所以当没有使用严格模式的时候，它就被绑定在了全局 window 对象上了。<br>在内层函数中维持 this 的值的方法：<br>为了解决传入 forEach 的匿名函数中 this 值不正确的问题，我们使用一个常用的解决办法，即当我们进入 forEach 的时候，提前把 this 的值存到另一个变量中去。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123; tournament: &#34;The Masters&#34;, data: [ &#123;name: &#34;T. Woods&#34;, age: 37&#125;, &#123;name: &#34;P. Mickelson&#34;, age: 43&#125; ], &#10;clickHandler: function(event) &#123; &#10;// &#20026;&#20102;&#24403; this &#36824;&#25351;&#21521; user &#23545;&#35937;&#30340;&#26102;&#20505;&#25226;&#23427;&#30340;&#20540;&#20445;&#23384;&#19979;&#26469;&#65292;&#25105;&#20204;&#25226;&#23427;&#23384;&#21040;&#21478;&#19968;&#20010;&#21464;&#37327;&#20013; &#10;// &#25105;&#20204;&#25226; this &#20445;&#23384;&#21040; theUserObj &#21464;&#37327;&#20013;&#21435;&#65292;&#36825;&#26679;&#25105;&#20204;&#23601;&#21487;&#20197;&#22312;&#20043;&#21518;&#20351;&#29992;&#20102; &#10;var theUserObj = this; this.data.forEach(function(person) &#123; &#10;// &#25105;&#20204;&#23558; this.tournament &#26367;&#25442;&#25104; theUserObj.tournament &#10;console.log(person.name + &#34; is playing at &#34; + theUserObj.tournament); &#125;); &#125; &#125; &#10;user.clickHandler(); &#10;// T. Woods is playing at The Masters &#10;// P. Mickelson is playing at The Masters</span><br></pre></td></tr></table></figure>
<p>值得注意的是，许多 JavaScript 开发者喜欢把 this 存在一个叫做 that 的变量中（就像下面的代码那样）。我觉得用 that 来命名使用的时候十分不方便，所以尽量使用一个合适的名词来描述 this 所指向的对象，所以我在上述代码中使用了 var theUserObj = this。<br>// 一种十分常见的写法 var that = this; </p>
<ol>
<li>解决把一个 this 方法 赋给一个变量时出现的问题当我们把一个使用了 this 的方法赋给一个变量的时候，this 的值很可能出乎我们的意料，指向了其他的对象。我们来看一个例子：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#36825;&#20010; data &#21464;&#37327;&#26159;&#19968;&#20010;&#20840;&#23616;&#21464;&#37327; &#10;var data = [ &#123;name: &#34;Samantha&#34;, age: 12&#125;, &#10;&#123;name: &#34;Alexis&#34;, age: 14&#125; ]; &#10;var user = &#123; &#10;// &#36825;&#20010; data &#21464;&#37327;&#26159; user &#23545;&#35937;&#30340;&#19968;&#20010;&#23646;&#24615;&#10; data: [ &#123;name: &#34;T. Woods&#34;, age: 37&#125;, &#10; &#123;name: &#34;P. Mickelson&#34;, age: 43&#125; ], &#10; showData: function(event) &#123; &#10; var randomNum = ((Math.random() * 2 | 0) + 1) - 1; &#10; // 0 &#21644; 1 &#20043;&#38388;&#30340;&#38543;&#26426;&#25968; &#10; // &#19979;&#38754;&#36825;&#34892;&#38543;&#26426;&#25171;&#21360;&#19968;&#20010; data &#25968;&#32452;&#20013;&#30340;&#20154;&#30340;&#20449;&#24687; &#10; console.log(this.data[randomNum].name + &#34; &#34; + this.data[randomNum].age); &#125; &#125; /&#10; / &#25226; user.showData &#36171;&#20540;&#32473;&#19968;&#20010;&#21464;&#37327; &#10; var showUserData = user.showData; &#10; // &#24403;&#25105;&#20204;&#25191;&#34892; showUserData &#20989;&#25968;&#30340;&#26102;&#20505;&#65292;&#25171;&#21360;&#22312; console &#20013;&#30340;&#20540;&#26469;&#33258;&#20110;&#20840;&#23616;&#30340; data &#25968;&#32452;&#65292;&#32780;&#19981;&#26159; user &#23545;&#35937;&#30340; data &#23646;&#24615; showUserData(); &#10; // Samantha 12 &#65288;&#26469;&#33258;&#20840;&#23616; data &#25968;&#32452;&#65289;</span><br></pre></td></tr></table></figure>
<p>当把含有 this 的方法赋值给一个变量时维持 this 的值的方法<br>我们可以使用 bind 方法来显式地设置 this 的值来解决这个问题：<br>// 把 showData 方法和 user 对象绑定起来 var showUserData = user.showData.bind(user); // 现在我们可以从 user 对象中获取值了，因为 this 关键字和 user 对象绑定在一起了 showUserData(); // P. Mickelson 43 </p>
<ol>
<li>解决当借用方法的时候 this 的值不正确的问题在 JavaScript 开发中，借用方法（borrow methods）是一个很常见的用法，作为一个 JavaScript 开发者，我们肯定会在实践中不断地遇到这个问题。而且每次我们也乐于使用这种节约时间的方法。如果你想了解更多关于方法借用的问题，请阅读我的这篇详细解析的文章，Javascript 进阶：Apply, Call 和 Bind 方法详解。<br>让我们来看看当处于借用方法这样的上下文的时候，this 的相关表现：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#25105;&#20204;&#26377;&#20004;&#20010;&#23545;&#35937;&#12290;&#20854;&#20013;&#19968;&#20010;&#26377;&#19968;&#20010;&#21483;&#20570; avg() &#30340;&#26041;&#27861;&#65292;&#32780;&#21478;&#19968;&#20010;&#27809;&#26377; &#10;// &#25152;&#20197;&#25105;&#20204;&#24819;&#20511;&#29992;&#19968;&#19979; (avg()) &#36825;&#20010;&#26041;&#27861; &#10;var gameController = &#123; scores: [20, 34, 55, 46, 77], &#10;avgScore: null,&#10;players: [ &#123;name: &#34;Tommy&#34;, playerID: 987, age: 23&#125;, &#123;name: &#34;Pau&#34;, playerID: 87, age: 33&#125; ] &#125; var appController = &#123; scores: [900, 845, 809, 950],&#10;avgScore: null, avg: function() &#123; &#10;var sumOfScores = this.scores.reduce(function(prev, cur, index, array) &#123; &#10;return prev + cur; &#10;&#125;); &#10;this.avgScore = sumOfScores / this.scores.length; &#125; &#125; &#10;// &#22914;&#26524;&#25105;&#20204;&#25191;&#34892;&#19979;&#38754;&#30340;&#20195;&#30721;&#65292; &#10;// gameController.avgScore &#23646;&#24615;&#23558;&#20250;&#34987;&#35774;&#32622;&#20026; appController &#23545;&#35937;&#30340; scores &#25968;&#32452;&#30340;&#24179;&#22343;&#25968; // &#19981;&#35201;&#25191;&#34892;&#19979;&#38754;&#36825;&#34892;&#20195;&#30721;&#65292;&#36825;&#21482;&#26159;&#29992;&#26469;&#35828;&#26126;&#30340;&#65292;&#32780;&#25105;&#20204;&#29616;&#22312;&#24819;&#35753; appController.avgScore &#20445;&#25345; null &#20540; gameController.avgScore = appController.avg();</span><br></pre></td></tr></table></figure>
<p>在 avg 方法中的 this 不会指向 gameController 对象，而会指向appController 对象，因为它是被 appController 对象所调用的。<br>解决当借用方法时 this 指向出错的问题<br>要解决这个问题，我们只要确保在 appController.avg() 中的 this 指向gameController 就可以了。我们可以使用 apply() 方法来实现：<br>// 注意我们使用的是 apply() 方法，所以第二个参数必须是一个数组，这个数组中包含了要传入 appController.avg() 的参数<br> appController.avg.apply(gameController, gameController.scores);<br> // 即使我们从 appController 对象中借用了 avg() 方法，gameController 的 avgScore 属性仍被成功地设置了<br> console.log(gameController.avgScore);<br> // 46.4<br> // appController.avgScore 的值仍然是 null。它没有被更新，只有<br> gameController.avgScore 被更新了 console.log(appController.avgScore);<br> // null </p>
<p>gameController 对象借用了 appController 的 avg() 方法。在appController.avg() 中的 this 的值会被设置成 gameController 对象，因为我们把 gameController 作为第一个参数传入了 apply() 方法中。传入apply() 方法的第一个参数会被显式地设置为 this 的值。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/01/20/10/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          TCP/IP 协议
        
      </div>
    </a>
  
  
    <a href="/2016/01/12/9/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">http协议 状态码</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>








</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div>&copy; 2016 任先生在路上 的博客 , 技术 
        <a href="http://hexo.io/" target="_blank">Hexo</a>  
      </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>