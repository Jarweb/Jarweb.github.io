<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>this | Jar-R</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="global this

在浏览器里，在全局范围内，this等价于window对象。

1&amp;#60;script type=&amp;#34;text/javascript&amp;#34;&amp;#62;&amp;#10;&amp;#9;onsole.log(this === window);&amp;#10;&amp;#9;//true 3&amp;#10;&amp;#60;/script&amp;#62;">
<meta property="og:type" content="article">
<meta property="og:title" content="this">
<meta property="og:url" content="http://Jarweb.com/2016/04/09/this/index.html">
<meta property="og:site_name" content="Jar-R">
<meta property="og:description" content="global this

在浏览器里，在全局范围内，this等价于window对象。

1&amp;#60;script type=&amp;#34;text/javascript&amp;#34;&amp;#62;&amp;#10;&amp;#9;onsole.log(this === window);&amp;#10;&amp;#9;//true 3&amp;#10;&amp;#60;/script&amp;#62;">
<meta property="og:updated_time" content="2016-07-13T17:14:18.496Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="this">
<meta name="twitter:description" content="global this

在浏览器里，在全局范围内，this等价于window对象。

1&amp;#60;script type=&amp;#34;text/javascript&amp;#34;&amp;#62;&amp;#10;&amp;#9;onsole.log(this === window);&amp;#10;&amp;#9;//true 3&amp;#10;&amp;#60;/script&amp;#62;">
  
    <link rel="alternative" href="/atom.xml" title="Jar-R" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">任先生在路上</a></h1>
		</hgroup>

		
		<p class="header-subtitle" style="margin-bottom:20px;">Good things are coming !</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger" style="display:none;"></div>
  		<h1 class="header-author js-mobile-header hide">任先生在路上</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">任先生在路上</h1>
			</hgroup>
			
			<p class="header-subtitle">Good things are coming !</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-this" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/09/this/" class="article-date">
  	<time datetime="2016-04-08T16:00:00.000Z" itemprop="datePublished">2016-04-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      this
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/this/">this</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>global this</p>
<ul>
<li>在浏览器里，在全局范围内，this等价于window对象。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;script type=&#34;text/javascript&#34;&#62;&#10;&#9;onsole.log(this === window);&#10;&#9;//true 3&#10;&#60;/script&#62;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li><p>在浏览器里，在全局范围内，用var声明一个变量和给this或者window添加属性是等价的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;script type=&#34;text/javascript&#34;&#62;&#10;&#9;var foo = &#34;bar&#34;;&#10;&#9;onsole.log(this.foo); //logs &#34;bar&#34;&#10;&#9;console.log(window.foo); //logs &#34;bar&#34;&#10;&#60;/script&#62;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你在声明一个变量的时候没有使用var或者let(ECMAScript 6),你就是在给全局的this添加或者改变属性值。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;script type=&#34;text/javascript&#34;&#62;&#10;foo = &#34;bar&#34;;&#10;function testThis() &#123;&#10;&#9;foo = &#34;foo&#34;;&#10;&#125;&#10;console.log(this.foo); //logs &#34;bar&#34;&#10;testThis();&#10;console.log(this.foo); //logs &#34;foo&#34;&#10;&#60;/script&#62;</span><br></pre></td></tr></table></figure>
<ul>
<li>在node环境里，如果使用REPL(Read-Eval-Print Loop，简称REPL:读取-求值-输出,是一个简单的，交互式的编程环境)来执行程序,this并不是最高级的命名空间，最高级的是global.</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this &#123;&#10;ArrayBuffer: [Function: ArrayBuffer],&#10;Int8Array: &#123; [Function: Int8Array] BYTES_PER_ELEMENT: 1 &#125;,&#10;Uint8Array: &#123; [Function: Uint8Array] BYTES_PER_ELEMENT: 1 &#125;,&#10;  ...&#10;//global === this true</span><br></pre></td></tr></table></figure>
<ul>
<li>在node环境里，如果执行一个js脚本，在全局范围内，this以一个空对象开始作为最高级的命名空间，这个时候，它和global不是等价的。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.js&#33050;&#26412;&#20869;&#23481;&#65306;&#10;console.log(this);&#10;console.log(this === global);&#10;REPL&#36816;&#34892;&#33050;&#26412;&#10;$ node test.js&#10;&#123;&#125;&#10;false</span><br></pre></td></tr></table></figure>
<ul>
<li>在node环境里，在全局范围内，如果你用REPL执行一个脚本文件，用var声明一个变量并不会和在浏览器里面一样将这个变量添加给this。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.js:&#10;var foo = &#34;bar&#34;;&#10;console.log(this.foo);&#10;$ node test.js&#10;undefined</span><br></pre></td></tr></table></figure>
<ul>
<li><p>但是如果你不是用REPL执行脚本文件，而是直接执行代码，结果和在浏览器里面是一样的(神坑)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#34;bar&#34;;&#10;this.foo&#10;bar&#10;global.foo&#10;bar</span><br></pre></td></tr></table></figure>
</li>
<li><p>在node环境里，用REPL运行脚本文件的时候，如果在声明变量的时候没有使用var或者let，这个变量会自动添加到global对象，但是不会自动添加给this对象。如果是直接执行代码，则会同时添加给global和this</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.js&#10;foo = &#34;bar&#34;;&#10;console.log(this.foo);&#10;console.log(global.foo);&#10;$ node test.js&#10;undefined&#10;bar</span><br></pre></td></tr></table></figure>
<p>上面的八种情况可能大家已经绕晕了，总结起来就是：在浏览器里面this是老大，它等价于window对象，如果你声明一些全局变量(不管在任何地方)，这些变量都会作为this的属性。在node里面，有两种执行JavaScript代码的方式，一种是直接执行写好的JavaScript文件，另外一种是直接在里面执行一行行代码。对于直接运行一行行JavaScript代码的方式，global才是老大，this和它是等价的。在这种情况下，和浏览器比较相似，也就是声明一些全局变量会自动添加给老大global，顺带也会添加给this。但是在node里面直接脚本文件就不一样了，你声明的全局变量不会自动添加到this，但是会添加到global对象。所以相同点是，在全局范围内，全局变量终究是属于老大的。</p>
<p>function this</p>
<ul>
<li>无论是在浏览器环境还是node环境， 除了在DOM事件处理程序里或者给出了thisArg(接下来会讲到)外，如果不是用new调用，在函数里面使用this都是指代全局范围的this。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;script type=&#34;text/javascript&#34;&#62;&#10;foo = &#34;bar&#34;;&#10;function testThis() &#123;&#10;&#9;this.foo = &#34;foo&#34;;&#10;&#125;&#10;console.log(this.foo); //logs &#34;bar&#34;&#10;testThis();&#10;console.log(this.foo); //logs &#34;foo&#34;&#10;&#60;/script&#62;&#10;&#10;test.js&#10;&#10;foo = &#34;bar&#34;;&#10;function testThis () &#123;&#10;&#9;this.foo = &#34;foo&#34;;&#10;&#125;&#10;console.log(global.foo);&#10;testThis();&#10;console.log(global.foo);&#10;$ node test.js&#10;bar&#10;foo</span><br></pre></td></tr></table></figure>
<ul>
<li>除非你使用严格模式，这时候this就会变成undefined。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;script type=&#34;text/javascript&#34;&#62;&#10;foo = &#34;bar&#34;;&#10;function testThis() &#123;&#10;&#9;&#34;use strict&#34;;&#10;&#9;this.foo = &#34;foo&#34;;&#10;&#125;&#10;console.log(this.foo); //logs &#34;bar&#34;&#10;testThis(); //Uncaught TypeError: Cannot set property &#39;foo&#39; of undefined&#10;&#60;/script&#62;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果你在调用函数的时候在前面使用了new，this就会变成一个新的值，和global的this脱离干系。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;script type=&#34;text/javascript&#34;&#62;&#10;foo = &#34;bar&#34;;&#10;function testThis() &#123;&#10;&#9;this.foo = &#34;foo&#34;;&#10;&#125;&#10;console.log(this.foo); //logs &#34;bar&#34;&#10;new testThis();&#10;console.log(this.foo); //logs &#34;bar&#34;&#10;console.log(new testThis().foo); //logs &#34;foo&#34;&#10;&#60;/script&#62;</span><br></pre></td></tr></table></figure>
<p>我更喜欢把新的值称作一个实例。<br>函数里面的this其实相对比较好理解，如果我们在一个函数里面使用this，需要注意的就是我们调用函数的方式，如果是正常的方式调用函数，this指代全局的this，如果我们加一个new，这个函数就变成了一个构造函数，我们就创建了一个实例，this指代这个实例，这个和其他面向对象的语言很像。另外，写JavaScript很常做的一件事就是绑定事件处理程序，也就是诸如button.addEventListener(‘click’, fn, false)之类的，如果在fn里面需要使用this，this指代事件处理程序对应的对象，也就是button。<br>prototype this</p>
<ul>
<li>你创建的每一个函数都是函数对象。它们会自动获得一个特殊的属性prototype，你可以给这个属性赋值。当你用new的方式调用一个函数的时候，你就能通过this访问你给prototype赋的值了。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing() &#123;&#10;&#9;console.log(this.foo);&#10;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;var thing = new Thing(); //logs &#34;bar&#34;&#10;console.log(thing.foo); //logs &#34;bar&#34;</span><br></pre></td></tr></table></figure>
<ul>
<li>当你使用new为你的函数创建多个实例的时候，这些实例会共享你给prototype设定的值。对于下面的例子，当你调用this.foo的时候，都会返回相同的值，除非你在某个实例里面重写了自己的this.foo</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing() &#123;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;Thing.prototype.logFoo = function () &#123;&#10;&#9;console.log(this.foo);&#10;&#125;&#10;Thing.prototype.setFoo = function (newFoo) &#123;&#10;&#9;this.foo = newFoo;&#10;&#125;&#10;var thing1 = new Thing();&#10;var thing2 = new Thing();&#10;thing1.logFoo(); //logs &#34;bar&#34;&#10;thing2.logFoo(); //logs &#34;bar&#34;&#10;thing1.setFoo(&#34;foo&#34;);&#10;thing1.logFoo(); //logs &#34;foo&#34;;&#10;thing2.logFoo(); //logs &#34;bar&#34;;&#10;thing2.foo = &#34;foobar&#34;;&#10;thing1.logFoo(); //logs &#34;foo&#34;;&#10;thing2.logFoo(); //logs &#34;foobar&#34;;</span><br></pre></td></tr></table></figure>
<ul>
<li>实例里面的this是一个特殊的对象。你可以把this想成一种获取prototype的值的一种方式。当你在一个实例里面直接给this添加属性的时候，会隐藏prototype中与之同名的属性。如果你想访问prototype中的这个属性值而不是你自己设定的属性值，你可以通过在实例里面删除你自己添加的属性的方式来实现。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing() &#123;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;Thing.prototype.logFoo = function () &#123;&#10;&#9;console.log(this.foo);&#10;&#125;&#10;Thing.prototype.setFoo = function (newFoo) &#123;&#10;&#9;this.foo = newFoo;&#10;&#125;&#10;Thing.prototype.deleteFoo = function () &#123;&#10;&#9;delete this.foo;&#10;&#125;&#10;var thing = new Thing();&#10;thing.setFoo(&#34;foo&#34;);&#10;thing.logFoo(); //logs &#34;foo&#34;;&#10;thing.deleteFoo();&#10;thing.logFoo(); //logs &#34;bar&#34;;&#10;thing.foo = &#34;foobar&#34;;&#10;thing.logFoo(); //logs &#34;foobar&#34;;&#10;delete thing.foo;&#10;thing.logFoo(); //logs &#34;bar&#34;;</span><br></pre></td></tr></table></figure>
<ul>
<li>或者你也能直接通过引用函数对象的prototype 来获得你需要的值。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing() &#123;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;Thing.prototype.logFoo = function () &#123;&#10;&#9;console.log(this.foo, Thing.prototype.foo);&#10;&#125;&#10;var thing = new Thing();&#10;thing.foo = &#34;foo&#34;;&#10;thing.logFoo(); //logs &#34;foo bar&#34;;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过一个函数创建的实例会共享这个函数的prototype属性的值，如果你给这个函数的prototype赋值一个Array，那么所有的实例都会共享这个Array，除非你在实例里面重写了这个Array，这种情况下，函数的prototype的Array就会被隐藏掉。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing() &#123;&#125;&#10;Thing.prototype.things = [];&#10;var thing1 = new Thing();&#10;var thing2 = new Thing();&#10;thing1.things.push(&#34;foo&#34;);&#10;console.log(thing2.things); //logs [&#34;foo&#34;]</span><br></pre></td></tr></table></figure>
<ul>
<li>给一个函数的prototype赋值一个Array通常是一个错误的做法。如果你想每一个实例有他们专属的Array，你应该在函数里面创建而不是在prototype里面创建。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing() &#123;&#10;&#9;this.things = [];&#10;&#125;&#10;var thing1 = new Thing();&#10;var thing2 = new Thing();&#10;thing1.things.push(&#34;foo&#34;);&#10;console.log(thing1.things); //logs [&#34;foo&#34;]&#10;console.log(thing2.things); //logs []</span><br></pre></td></tr></table></figure>
<ul>
<li>实际上你可以通过把多个函数的prototype链接起来的从而形成一个原型链，因此this就会魔法般地沿着这条原型链往上查找直到找你你需要引用的值。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing1() &#123;&#125;&#10;Thing1.prototype.foo = &#34;bar&#34;;&#10;function Thing2() &#123;&#125;&#10;Thing2.prototype = new Thing1();&#10;var thing = new Thing2();&#10;console.log(thing.foo); //logs &#34;bar&#34;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing1() &#123;&#125;&#10;Thing1.prototype.foo = &#34;bar&#34;;&#10;function Thing2() &#123;&#10; &#9;this.foo = &#34;foo&#34;;&#10; &#125;&#10; Thing2.prototype = new Thing1();&#10; function Thing3() &#123;&#125;&#10; Thing3.prototype = new Thing2();&#10; var thing = new Thing3();&#10; console.log(thing.foo); //logs &#34;foo&#34;</span><br></pre></td></tr></table></figure>
<ul>
<li>我喜欢把被赋值给prototype的函数叫做方法。在上面的例子中，我已经使用过方法了，如logFoo。这些方法有着相同的prototype，即创建这些实力的原始函数。我通常把这些原始函数叫做构造函数。在prototype里面定义的方法里面使用this会影响到当前实例的原型链的上游的this。这意味着你直接给this赋值的时候，隐藏了原型链上游的相同的属性值。这个实例的任何方法都会使用这个最新的值而不是原型里面定义的这个相同的值。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing1() &#123;&#125;&#10;hing1.prototype.foo = &#34;bar&#34;;&#10;Thing1.prototype.logFoo = function () &#123;&#10;&#9;console.log(this.foo);&#10;&#125;&#10;function Thing2() &#123;&#10;&#9;this.foo = &#34;foo&#34;;&#10;&#125;&#10;Thing2.prototype = new Thing1();&#10;var thing = new Thing2();&#10;thing.logFoo(); //logs &#34;foo&#34;;&#10;`</span><br></pre></td></tr></table></figure>
<ul>
<li>在JavaScript里面你可以嵌套函数，也就是你可以在函数里面定义函数。嵌套函数可以通过闭包捕获父函数的变量，但是这个函数没有继承this</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing() &#123;&#125;&#10;hing.prototype.foo = &#34;bar&#34;;&#10;Thing.prototype.logFoo = function () &#123;&#10;&#9;var info = &#34;attempting to log this.foo:&#34;;&#10;function doIt() &#123;&#10;&#9;console.log(info, this.foo);&#10;&#125;&#10;doIt();&#10;&#125;&#10;var thing = new Thing();&#10;thing.logFoo(); //logs &#34;attempting to log this.foo: undefined&#34;</span><br></pre></td></tr></table></figure>
<p>在doIt里面的this是global对象或者在严格模式下面是undefined。这是造成很多不熟悉JavaScript的人深陷 this陷阱的根源。在这种情况下事情变得非常糟糕，就像你把一个实例的方法当作一个值，把这个值当作函数参数传递给另外一个函数但是却不把这个实例传递给这个函数一样。在这种情况下，一个方法里面的环境变成了全局范围，或者在严格模式下面的undefined。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing() &#123;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;Thing.prototype.logFoo = function () &#123;&#10;&#9;console.log(this.foo);&#10;&#125;&#10;function doIt(method) &#123;&#10;&#9;method();&#10;&#125;&#10;var thing = new Thing();&#10;thing.logFoo(); //logs &#34;bar&#34;&#10;doIt(thing.logFoo); //logs undefined</span><br></pre></td></tr></table></figure>
<ul>
<li>一些人喜欢先把this捕获到一个变量里面，通常这个变量叫做self，来避免上面这种情况的发生。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing() &#123;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;&#10;Thing.prototype.logFoo = function () &#123;&#10;&#9;&#9;var self = this;&#10;&#9;&#9;var info = &#34;attempting to log this.foo:&#34;;&#10;&#9;function doIt() &#123;&#10;&#9;&#9;console.log(info, self.foo);&#10;&#9;&#125;&#10;&#9;doIt();&#10;&#125;&#10;var thing = new Thing();&#10;thing.logFoo(); //logs &#34;attempting to log this.foo: bar&#34;</span><br></pre></td></tr></table></figure>
<ul>
<li>但是当你需要把一个方法作为一个值传递给一个函数的时候并不管用。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing() &#123;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;Thing.prototype.logFoo = function () &#123;&#10;&#9;var self = this;&#10;&#9;function doIt() &#123;&#10;&#9;&#9;console.log(self.foo);&#10;&#9;&#125;&#10;&#9;doIt();&#10;&#125;&#10;function doItIndirectly(method) &#123;&#10;&#9;method();&#10;&#125;&#10;var thing = new Thing();&#10;thing.logFoo(); //logs &#34;bar&#34;&#10;doItIndirectly(thing.logFoo); //logs undefined</span><br></pre></td></tr></table></figure>
<ul>
<li>你可以通过bind将实例和方法一切传递给函数来解决这个问题，bind是一个函数定义在所有函数和方法的函数对象上面</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing() &#123;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;Thing.prototype.logFoo = function () &#123;&#10;&#9;console.log(this.foo);&#10;&#125;&#10;function doIt(method) &#123;&#10;&#9;method();&#10;&#125;&#10;var thing = new Thing();&#10;doIt(thing.logFoo.bind(thing)); //logs bar</span><br></pre></td></tr></table></figure>
<ul>
<li>你同样可以使用apply和call来在新的上下文中调用方法或函数。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;function Thing() &#123;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;Thing.prototype.logFoo = function () &#123;&#10;&#9;function doIt() &#123;&#10;&#9;&#9;console.log(this.foo);&#10;&#9;&#125;&#10;&#9;doIt.apply(this);&#10;&#125;&#10;function doItIndirectly(method) &#123;&#10;&#9;method();&#10;&#125;&#10;var thing = new Thing();&#10;doItIndirectly(thing.logFoo.bind(thing)); //logs bar</span><br></pre></td></tr></table></figure>
<ul>
<li>你可以用bind来代替任何一个函数或者方法的this，即便它没有赋值给实例的初始prototype。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;function Thing() &#123;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;&#9;function logFoo(aStr) &#123;&#10;&#9;&#9;console.log(aStr, this.foo);&#10;&#9;&#125;&#10;var thing = new Thing();&#10;logFoo.bind(thing)(&#34;using bind&#34;); //logs &#34;using bind bar&#34;&#10;logFoo.apply(thing, [&#34;using apply&#34;]); //logs &#34;using apply bar&#34;&#10;logFoo.call(thing, &#34;using call&#34;); //logs &#34;using call bar&#34;&#10;logFoo(&#34;using nothing&#34;); //logs &#34;using nothing undefined&#34;</span><br></pre></td></tr></table></figure>
<ul>
<li>你应该避免在构造函数里面返回任何东西，因为这可能代替本来应该返回的实例。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;function Thing() &#123;&#10;&#9;return &#123;&#125;;&#10;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;Thing.prototype.logFoo = function () &#123;&#10;&#9;console.log(this.foo);&#10;&#125;&#10;var thing = new Thing();&#10;thing.logFoo(); //Uncaught TypeError: undefined is not a function</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>奇怪的是，如果你在构造函数里面返回了一个原始值，上面所述的情况并不会发生并且返回语句被忽略了。最好不要在你将通过new调用的构造函数里面返回任何类型的数据，即便你知道自己正在做什么。如果你想创建一个工厂模式，通过一个函数来创建一个实例，这个时候不要使用new来调用函数。当然这个建议是可选的。</p>
<ul>
<li>你可以通过使用Object.create来避免使用new，这样同样能够创建一个实例。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;function Thing() &#123;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;Thing.prototype.logFoo = function () &#123;&#10;&#9;console.log(this.foo);&#10;&#125;&#10;var thing = Object.create(Thing.prototype);&#10;thing.logFoo(); //logs &#34;bar&#34;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这种情况下并不会调用构造函数</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;function Thing() &#123;&#10;&#9;this.foo = &#34;foo&#34;;&#10;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;Thing.prototype.logFoo = function () &#123;&#10;&#9;console.log(this.foo);&#10;&#125;&#10;var thing = Object.create(Thing.prototype);&#10;thing.logFoo(); //logs &#34;bar&#34;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为Object.create不会调用构造函数的特性在你继承模式下你想通过原型链重写构造函数的时候非常有用。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;function Thing1() &#123;&#10;this.foo = &#34;foo&#34;;&#10;&#125;&#10;Thing1.prototype.foo = &#34;bar&#34;;&#10;function Thing2() &#123;&#10;&#9;this.logFoo(); //logs &#34;bar&#34;&#10;&#9;Thing1.apply(this);&#10;&#9;this.logFoo(); //logs &#34;foo&#34;&#10;&#125;&#10;Thing2.prototype = Object.create(Thing1.prototype);&#10;&#9;Thing2.prototype.logFoo = function () &#123;&#10;&#9;console.log(this.foo);&#10;&#125;&#10;var thing = new Thing2();</span><br></pre></td></tr></table></figure>
<p>object this</p>
<ul>
<li>在一个对象的一个函数里，你可以通过this来引用这个对象的其他属性。这个用new来新建一个实例是不一样的。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;var obj = &#123;&#10;foo: &#34;bar&#34;,&#10;logFoo: function () &#123;&#10;&#9;console.log(this.foo);&#10;&#125;&#10;&#125;;&#10;obj.logFoo(); //logs &#34;bar&#34;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意，没有使用new，没有使用Object.create，也没有使用函数调用创建一个对象。你也可以将对象当作一个实例将函数绑定到上面。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;var obj = &#123;&#10;&#9;foo: &#34;bar&#34;&#10;&#125;;&#10;function logFoo() &#123;&#10;&#9;console.log(this.foo);&#10;&#125;&#10;logFoo.apply(obj); //logs &#34;bar&#34;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当你用这种方式使用this的时候，并不会越出当前的对象。只有有相同直接父元素的属性才能通过this共享变量</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;var obj = &#123;&#10;&#9;foo: &#34;bar&#34;,&#10;&#9;deeper: &#123;&#10;&#9;&#9;logFoo: function () &#123;&#10;&#9;&#9;&#9;console.log(this.foo);&#10;&#9;&#9;&#125;&#10;&#9;&#125;&#10;&#125;;&#10;obj.deeper.logFoo(); //logs undefined&#10;`</span><br></pre></td></tr></table></figure>
</li>
<li><p>你可以直接通过对象引用你需要的属性</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;var obj = &#123;&#10;    foo: &#34;bar&#34;,&#10;    deeper: &#123;&#10;        logFoo: function () &#123; console.log(obj.foo);&#10;        &#125;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>obj.deeper.logFoo(); //logs “bar”</p>
<p>DOM event this</p>
<ul>
<li>在一个HTML DOM事件处理程序里面，this始终指向这个处理程序被所绑定到的HTML DOM节点</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;function Listener() &#123;&#10;&#9;document.getElementById(&#34;foo&#34;).addEventListener(&#34;click&#34;,&#10;&#9;this.handleClick);&#10;&#125;&#10;Listener.prototype.handleClick = function (event) &#123;&#10;&#9;console.log(this); //logs&#10;&#9;&#34;&#60;div id=&#34;foo&#34;&#62;&#60;/div&#62;&#34;&#125;&#10;var listener = new Listener();&#10;document.getElementById(&#34;foo&#34;).click();</span><br></pre></td></tr></table></figure>
<ul>
<li>除非你自己通过bind切换了上下文</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;function Listener() &#123;&#10;&#9;document.getElementById(&#34;foo&#34;).addEventListener(&#34;click&#34;,&#10;&#9;this.handleClick.bind(this));&#10;&#125;&#10;Listener.prototype.handleClick = function (event) &#123;&#10;&#9;console.log(this); //logs&#10;&#9;Listener &#123;handleClick: function&#125;&#10;&#125;&#10;var listener = new Listener();&#10;document.getElementById(&#34;foo&#34;).click();</span><br></pre></td></tr></table></figure>
<ul>
<li>在HTML节点的属性里面，你可以放置JavaScript代码，this指向了这个元素</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#60;div id=&#34;foo&#34; onclick=&#34;console.log(this);&#34;&#62;&#60;/div&#62;&#10;&#60;script type=&#34;text/javascript&#34;&#62;&#10;document.getElementById(&#34;foo&#34;).click(); //logs &#60;div id=&#34;foo&#34;...&#10;&#60;/script&#62;</span><br></pre></td></tr></table></figure>
<p>override this</p>
<ul>
<li>你不能重写this，因为它是保留字。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;function test () &#123;&#10;&#9;var this = &#123;&#125;; // Uncaught SyntaxError: Unexpected token this&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>eval this</p>
<ul>
<li>你可以通过eval来访问this</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing () &#123;&#10;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;Thing.prototype.logFoo = function () &#123; eval(&#34;console.log(this.foo)&#34;); //logs &#34;bar&#34; &#125;&#10;var thing = new Thing();&#10;thing.logFoo();</span><br></pre></td></tr></table></figure>
<p>这会造成一个安全问题，除非不用eval，没有其他方式来避免这个问题。</p>
<ul>
<li>在通过Function来创建一个函数的时候，同样能够访问this</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing () &#123;&#10;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;Thing.prototype.logFoo = new Function(&#34;console.log(this.foo);&#34;);&#10;var thing = new Thing();&#10;thing.logFoo(); //logs &#34;bar&#34;</span><br></pre></td></tr></table></figure>
<p>with this</p>
<ul>
<li>你可以通过with来将this添加到当前的执行环境，并且读写this的属性的时候不需要通过this</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing () &#123;&#125;&#10;Thing.prototype.foo = &#34;bar&#34;;&#10;Thing.prototype.logFoo = function () &#123;&#10;&#9;with (this) &#123;&#10;&#9;&#9;console.log(foo);&#10;&#9;&#9;foo = &#34;foo&#34;;&#10;&#9;&#125;&#10;&#125;&#10;var thing = new Thing();&#10;thing.logFoo(); // logs &#34;bar&#34;&#10;console.log(thing.foo); // logs &#34;foo&#34;</span><br></pre></td></tr></table></figure>
<p>jQuery this</p>
<ul>
<li>和HTML DOM元素节点的事件处理程序一样，在许多情况下JQuery的this都指向HTML元素节点。这在事件处理程序和一些方便的方法中都是管用的，比如$.each</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;div class=&#34;foo bar1&#34;&#62;&#60;/div&#62;&#10;&#60;div class=&#34;foo bar2&#34;&#62;&#60;/div&#62;&#10;&#60;script type=&#34;text/javascript&#34;&#62;&#10;$(&#34;.foo&#34;).each(function () &#123;&#10;&#9;console.log(this); //logs&#10;&#9;&#60;div class=&#34;foo...&#10;&#125;);&#10;$(&#34;.foo&#34;).on(&#34;click&#34;, function () &#123;&#10;&#9;console.log(this); //logs&#10;&#9;&#60;div class=&#34;foo...&#10;&#125;);&#10;$(&#34;.foo&#34;).each(function () &#123;&#10;&#9;this.click();&#10;&#125;);&#10;&#60;/script&#62;</span><br></pre></td></tr></table></figure>
<p>thisArg this如果你用过underscore.js 或者 lo-dash 你可能知道许多类库的方法可以通过一个叫做thisArg 的函数参数来传递实例，这个函数参数会作为this的上下文。举个例子，这适用于_.each。原生的JavaScript在ECMAScript 5的时候也允许函数传递一个thisArg参数了，比如forEach。事实上，之前阐述的bind，apply和call的使用已经给你创造了传递thisArg参数给函数的机会。这个参数将this绑定为你所传递的对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Thing(type) &#123;&#10;&#9;this.type = type;&#10;&#125;&#10;Thing.prototype.log = function (thing) &#123;&#10;&#9;console.log(this.type, thing);&#10;&#125;&#10;Thing.prototype.logThings = function (arr) &#123;&#10;&#9;arr.forEach(this.log, this); // logs &#34;fruit apples...&#34;&#10;&#9;_.each(arr, this.log, this); //logs &#34;fruit apples...&#34;&#10;&#125;&#10;var thing = new Thing(&#34;fruit&#34;);&#10;thing.logThings([&#34;apples&#34;, &#34;oranges&#34;, &#34;strawberries&#34;, &#34;bananas&#34;]);</span><br></pre></td></tr></table></figure>
<p>这使得代码变得更加简介，因为避免了一大堆bind语句、函数嵌套和this暂存的使用。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/04/09/数据类型/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          数据类型变化
        
      </div>
    </a>
  
  
    <a href="/2016/04/07/捕获冒泡/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">捕获与冒泡</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>








</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div>&copy; 2016 任先生在路上 的博客 , 技术 
        <a href="http://hexo.io/" target="_blank">Hexo</a>  
      </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>