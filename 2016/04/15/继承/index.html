<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>继承 | Jar-R</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="js里常用的如下两种继承方式：

原型链继承（对象间的继承）
类式继承（构造函数间的继承）

原型式继承与类式继承类式继承是在子类型构造函数的内部调用超类型的构造函数。严格的类式继承并不是很常见，一般都是组合着用：1function Super()&amp;#123;&amp;#10; this.colors=[&amp;#34;red&amp;#34;,&amp;#34;blue&amp;#34;];&amp;#10;&amp;#125;&amp;#10;&amp;#10;">
<meta property="og:type" content="article">
<meta property="og:title" content="继承">
<meta property="og:url" content="http://Jarweb.com/2016/04/15/继承/index.html">
<meta property="og:site_name" content="Jar-R">
<meta property="og:description" content="js里常用的如下两种继承方式：

原型链继承（对象间的继承）
类式继承（构造函数间的继承）

原型式继承与类式继承类式继承是在子类型构造函数的内部调用超类型的构造函数。严格的类式继承并不是很常见，一般都是组合着用：1function Super()&amp;#123;&amp;#10; this.colors=[&amp;#34;red&amp;#34;,&amp;#34;blue&amp;#34;];&amp;#10;&amp;#125;&amp;#10;&amp;#10;">
<meta property="og:updated_time" content="2016-07-13T16:49:23.780Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="继承">
<meta name="twitter:description" content="js里常用的如下两种继承方式：

原型链继承（对象间的继承）
类式继承（构造函数间的继承）

原型式继承与类式继承类式继承是在子类型构造函数的内部调用超类型的构造函数。严格的类式继承并不是很常见，一般都是组合着用：1function Super()&amp;#123;&amp;#10; this.colors=[&amp;#34;red&amp;#34;,&amp;#34;blue&amp;#34;];&amp;#10;&amp;#125;&amp;#10;&amp;#10;">
  
    <link rel="alternative" href="/atom.xml" title="Jar-R" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">任先生在路上</a></h1>
		</hgroup>

		
		<p class="header-subtitle" style="margin-bottom:20px;">Good things are coming !</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger" style="display:none;"></div>
  		<h1 class="header-author js-mobile-header hide">任先生在路上</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">任先生在路上</h1>
			</hgroup>
			
			<p class="header-subtitle">Good things are coming !</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-继承" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/15/继承/" class="article-date">
  	<time datetime="2016-04-14T16:00:00.000Z" itemprop="datePublished">2016-04-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      继承
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js原生/">js原生</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>js里常用的如下两种继承方式：</p>
<ul>
<li>原型链继承（对象间的继承）</li>
<li>类式继承（构造函数间的继承）</li>
</ul>
<p>原型式继承与类式继承类式继承是在子类型构造函数的内部调用超类型的构造函数。<br>严格的类式继承并不是很常见，一般都是组合着用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Super()&#123;&#10; this.colors=[&#34;red&#34;,&#34;blue&#34;];&#10;&#125;&#10;&#10;function Sub()&#123;&#10; Super.call(this);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>原型式继承是借助已有的对象创建新的对象，将子类的原型指向父类，就相当于加入了父类这条原型链<br>原型链继承为了让子类继承父类的属性（也包括方法），首先需要定义一个构造函数。然后，将父类的新实例赋值给构造函数的原型。代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;script&#62;&#10; function Parent()&#123;&#10; &#9;this.name = &#39;mike&#39;;&#10; &#125;&#10;&#10; function Child()&#123;&#10; &#9;this.age = 12;&#10; &#125;&#10; Child.prototype = new Parent();&#10; //Child&#32487;&#25215;Parent&#65292;&#36890;&#36807;&#21407;&#22411;&#65292;&#24418;&#25104;&#38142;&#26465;&#10;&#10; var test = new Child();&#10; alert(test.age);&#10; alert(test.name);&#10; //&#24471;&#21040;&#34987;&#32487;&#25215;&#30340;&#23646;&#24615;&#10; //&#32487;&#32493;&#21407;&#22411;&#38142;&#32487;&#25215;&#10; function Brother()&#123;&#10; //brother&#26500;&#36896;&#10; &#9;this.weight = 60;&#10; &#125;&#10; Brother.prototype = new Child();&#10; //&#32487;&#32493;&#21407;&#22411;&#38142;&#32487;&#25215;&#10; var brother = new Brother();&#10; alert(brother.name);&#10; //&#32487;&#25215;&#20102;Parent&#21644;Child,&#24377;&#20986;mike&#10; alert(brother.age);&#10; //&#24377;&#20986;12&#10;&#60;/script&#62;</span><br></pre></td></tr></table></figure>
<p>以上原型链继承还缺少一环，那就是Object，所有的构造函数都继承自Object。而继承Object是自动完成的，并不需要我们自己手动继承，那么他们的从属关系是怎样的呢？<br>确定原型和实例的关系可以通过两种方式来确定原型和实例之间的关系。操作符instanceof和isPrototypeof()方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(brother instanceof Object)//true&#10;alert(test instanceof Brother);//false,test &#26159;brother&#30340;&#36229;&#31867;&#10;alert(brother instanceof Child);//true&#10;alert(brother instanceof Parent);//true</span><br></pre></td></tr></table></figure>
<p>只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型，因此，isPrototypeof()方法也会返回true<br>在js中，被继承的函数称为超类型（父类，基类也行），继承的函数称为子类型（子类，派生类）。使用原型继承主要由两个问题：<br>一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。<br>伪类解决引用共享和超类型无法传参的问题，我们可以采用“借用构造函数”技术<br>借用构造函数（类式继承）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;script&#62;&#10; function Parent(age)&#123;&#10; &#9;this.name = [&#39;mike&#39;,&#39;jack&#39;,&#39;smith&#39;];&#10; &#9;this.age = age;&#10; &#125;&#10;&#10; function Child(age)&#123;&#10; &#9;Parent.call(this,age);&#10; &#125;&#10; var test = new Child(21);&#10; alert(test.age);//21&#10; alert(test.name);//mike,jack,smith&#10; test.name.push(&#39;bill&#39;);&#10; alert(test.name);//mike,jack,smith,bill&#10;&#60;/script&#62;</span><br></pre></td></tr></table></figure>
<p>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起，所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承<br>组合继承</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;script&#62;&#10; function Parent(age)&#123;&#10; &#9;this.name = [&#39;mike&#39;,&#39;jack&#39;,&#39;smith&#39;];&#10; &#9;this.age = age;&#10; &#125;&#10; Parent.prototype.run = function () &#123;&#10; &#9;return this.name + &#39; are both&#39; + this.age;&#10; &#125;;&#10; function Child(age)&#123;&#10; &#9;Parent.call(this,age);//&#23545;&#35937;&#20882;&#20805;&#65292;&#32473;&#36229;&#31867;&#22411;&#20256;&#21442;&#10; &#125;&#10; Child.prototype = new Parent();//&#21407;&#22411;&#38142;&#32487;&#25215;&#10; var test = new Child(21);//&#20889;new Parent(21)&#20063;&#34892;&#10; alert(test.run());//mike,jack,smith are both21&#10;&#60;/script&#62;&#10;&#10;&#32452;&#21512;&#24335;&#32487;&#25215;&#26159;&#27604;&#36739;&#24120;&#29992;&#30340;&#19968;&#31181;&#32487;&#25215;&#26041;&#27861;&#65292;&#20854;&#32972;&#21518;&#30340;&#24605;&#36335;&#26159; &#20351;&#29992;&#21407;&#22411;&#38142;&#23454;&#29616;&#23545;&#21407;&#22411;&#23646;&#24615;&#21644;&#26041;&#27861;&#30340;&#32487;&#25215;&#65292;&#32780;&#36890;&#36807;&#20511;&#29992;&#26500;&#36896;&#20989;&#25968;&#26469;&#23454;&#29616;&#23545;&#23454;&#20363;&#23646;&#24615;&#30340;&#32487;&#25215;&#12290;&#36825;&#26679;&#65292;&#26082;&#36890;&#36807;&#22312;&#21407;&#22411;&#19978;&#23450;&#20041;&#26041;&#27861;&#23454;&#29616;&#20102;&#20989;&#25968;&#22797;&#29992;&#65292;&#21448;&#20445;&#35777;&#27599;&#20010;&#23454;&#20363;&#37117;&#26377;&#23427;&#33258;&#24049;&#30340;&#23646;&#24615;&#12290;&#10;call()&#30340;&#29992;&#27861;&#65306;&#35843;&#29992;&#19968;&#20010;&#23545;&#35937;&#30340;&#19968;&#20010;&#26041;&#27861;&#65292;&#20197;&#21478;&#19968;&#20010;&#23545;&#35937;&#26367;&#25442;&#24403;&#21069;&#23545;&#35937;&#12290;&#10;&#10;&#10;call([thisObj[,arg1[, arg2[, [,.argN]]]]])&#10;&#10;&#10;&#21407;&#22411;&#24335;&#32487;&#25215;&#36825;&#31181;&#32487;&#25215;&#20511;&#21161;&#21407;&#22411;&#24182;&#22522;&#20110;&#24050;&#26377;&#30340;&#23545;&#35937;&#21019;&#24314;&#26032;&#23545;&#35937;&#65292;&#21516;&#26102;&#36824;&#19981;&#29992;&#21019;&#24314;&#33258;&#23450;&#20041;&#31867;&#22411;&#30340;&#26041;&#24335;&#31216;&#20026;&#21407;&#22411;&#24335;&#32487;&#25215;&#10;&#10;```dash&#10;&#60;script&#62;&#10; function obj(o)&#123;&#10;&#9; function F()&#123;&#125;&#10;&#9; F.prototype = o;&#10;&#9; return new F();&#10; &#125;&#10; var box = &#123;&#10;&#9; name : &#39;trigkit4&#39;,&#10;&#9; arr : [&#39;brother&#39;,&#39;sister&#39;,&#39;baba&#39;]&#10; &#125;;&#10; var b1 = obj(box);&#10; alert(b1.name);//trigkit4&#10;&#10; b1.name = &#39;mike&#39;;&#10; alert(b1.name);//mike&#10;&#10; alert(b1.arr);//brother,sister,baba&#10; b1.arr.push(&#39;parents&#39;);&#10; alert(b1.arr);//brother,sister,baba,parents&#10;&#10; var b2 = obj(box);&#10; alert(b2.name);//trigkit4&#10; alert(b2.arr);//brother,sister,baba,parents&#10;&#60;/script&#62;</span><br></pre></td></tr></table></figure>
<p>原型式继承首先在obj()函数内部创建一个临时性的构造函数 ，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。<br>寄生式继承这种继承方式是把原型式+工厂模式结合起来，目的是为了封装创建的过程。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;script&#62;&#10; function create(o)&#123;&#10;&#9; var f= obj(o);&#10;&#9; f.run = function () &#123;&#10;&#9; return this.arr;//&#21516;&#26679;&#65292;&#20250;&#20849;&#20139;&#24341;&#29992;&#10; &#9;&#125;;&#10; &#9;return f;&#10; &#125;&#10;&#60;/script&#62;</span><br></pre></td></tr></table></figure>
<p>组合式继承的小问题组合式继承是js最常用的继承模式，但组合继承的超类型在使用过程中会被调用两次；一次是创建子类型的时候，另一次是在子类型构造函数的内部</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;script&#62;&#10; function Parent(name)&#123;&#10;&#9; this.name = name;&#10;&#9; this.arr = [&#39;&#21733;&#21733;&#39;,&#39;&#22969;&#22969;&#39;,&#39;&#29238;&#27597;&#39;];&#10; &#125;&#10;&#10; Parent.prototype.run = function () &#123;&#10; &#9;return this.name;&#10; &#125;;&#10;&#10; function Child(name,age)&#123;&#10;&#9; Parent.call(this,age);//&#31532;&#20108;&#27425;&#35843;&#29992;&#10;&#9; this.age = age;&#10; &#125;&#10;&#10;Child.prototype = new Parent();//&#31532;&#19968;&#27425;&#35843;&#29992;&#10;&#60;/script&#62;</span><br></pre></td></tr></table></figure>
<p>以上代码是之前的组合继承，那么寄生组合继承，解决了两次调用的问题。<br>寄生组合式继承</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;script&#62;&#10; function obj(o)&#123;&#10;&#9; function F()&#123;&#125;&#10;&#9; F.prototype = o;&#10;&#9; return new F();&#10; &#125;&#10; function create(parent,test)&#123;&#10;&#9; var f = obj(parent.prototype);//&#21019;&#24314;&#23545;&#35937;&#10;&#9; f.constructor = test;//&#22686;&#24378;&#23545;&#35937;&#10; &#125;&#10;&#10; function Parent(name)&#123;&#10;&#9; this.name = name;&#10;&#9; this.arr = [&#39;brother&#39;,&#39;sister&#39;,&#39;parents&#39;];&#10; &#125;&#10;&#10; Parent.prototype.run = function () &#123;&#10; &#9;return this.name;&#10; &#125;;&#10;&#10; function Child(name,age)&#123;&#10;&#9; Parent.call(this,name);&#10;&#9; this.age =age;&#10; &#125;&#10;&#10; inheritPrototype(Parent,Child);//&#36890;&#36807;&#36825;&#37324;&#23454;&#29616;&#32487;&#25215;&#10;&#10; var test = new Child(&#39;trigkit4&#39;,21);&#10; test.arr.push(&#39;nephew&#39;);&#10; alert(test.arr);//&#10; alert(test.run());//&#21482;&#20849;&#20139;&#20102;&#26041;&#27861;&#10;&#10; var test2 = new Child(&#39;jack&#39;,22);&#10; alert(test2.arr);//&#24341;&#29992;&#38382;&#39064;&#35299;&#20915;&#10;&#60;/script&#62;</span><br></pre></td></tr></table></figure>
<p>call和apply全局函数apply和call可以用来改变函数中this的指向，如下：<br>// 定义一个全局函数<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;&#10;&#9;console.log(this.fruit);&#10;&#125;&#10;&#10;// &#23450;&#20041;&#19968;&#20010;&#20840;&#23616;&#21464;&#37327;&#10;var fruit = &#34;apple&#34;;&#10;// &#33258;&#23450;&#20041;&#19968;&#20010;&#23545;&#35937;&#10;var pack = &#123;&#10;&#9;fruit: &#34;orange&#34;&#10;&#125;;&#10;&#10;// &#31561;&#20215;&#20110;window.foo();&#10;foo.apply(window); // &#34;apple&#34;,&#27492;&#26102;this&#31561;&#20110;window&#10;// &#27492;&#26102;foo&#20013;&#30340;this === pack&#10;foo.apply(pack); // &#34;orange&#34;</span><br></pre></td></tr></table></figure></p>
<p>简单原型链这是实现继承最简单的方式了，真的超简单，核心就一句话（在代码中用注释标明了）</p>
<p>1.具体实现<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Super()&#123;&#10; this.val = 1;&#10; this.arr = [1];&#10;&#125;&#10;function Sub()&#123;&#10; // ...&#10;&#125;&#10;Sub.prototype = new Super(); // &#26680;&#24515;&#10;&#10;var sub1 = new Sub();&#10;var sub2 = new Sub();&#10;sub1.val = 2;&#10;sub1.arr.push(2);&#10;alert(sub1.val); // 2&#10;alert(sub2.val); // 1&#10;&#10;alert(sub1.arr); // 1, 2&#10;alert(sub2.arr); // 1, 2</span><br></pre></td></tr></table></figure></p>
<p>2.核心拿父类实例来充当子类原型对象<br>3.优缺点优点：</p>
<ol>
<li>简单，易于实现</li>
</ol>
<p>缺点：</p>
<pre><code>1. 修改sub1.arr后sub2.arr也变了，因为来自原型对象的引用属性是所有实例共享的。可以这样理解：执行sub1.arr.push(2);先对sub1进行属性查找，找遍了实例属性（在本例中没有实例属性），没找到，就开始顺着原型链向上找，拿到了sub1的原型对象，一搜身，发现有arr属性。于是给arr末尾插入了2，所以sub2.arr也变了
2. 创建子类实例时，无法向父类构造函数传参
</code></pre><p>借用构造函数简单原型链真够简单，可是存在2个致命缺点简直不能用，于是上个世纪末的jsers就想办法fix这2个缺陷，然后出现了借用构造函数方式<br>1.具体实现<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Super(val)&#123;&#10; this.val = val;&#10; this.arr = [1];&#10;&#10; this.fun = function()&#123;&#10; // ...&#10; &#125;&#10;&#125;&#10;function Sub(val)&#123;&#10; Super.call(this, val); // &#26680;&#24515;&#10; // ...&#10;&#125;&#10;&#10;var sub1 = new Sub(1);&#10;var sub2 = new Sub(2);&#10;sub1.arr.push(2);&#10;alert(sub1.val); // 1&#10;alert(sub2.val); // 2&#10;&#10;alert(sub1.arr); // 1, 2&#10;alert(sub2.arr); // 1&#10;&#10;alert(sub1.fun === sub2.fun); // false</span><br></pre></td></tr></table></figure></p>
<p>2.核心借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）</p>
<p>3.优缺点优点：</p>
<pre><code>1. 解决了子类实例共享父类引用属性的问题
2. 创建子类实例时，可以向父类构造函数传参
</code></pre><p>P.S.前辈就这么高效，两个缺陷瞬间修复<br>缺点：</p>
<pre><code>1. 无法实现函数复用，每个子类实例都持有一个新的fun函数，太多了就会影响性能，内存爆炸。。
</code></pre><p>组合继承（最常用）目前我们的借用构造函数方式还是有问题（无法实现函数复用），没关系，接着修复，jsers吭哧吭哧又搞出了组合继承</p>
<p>``dash<br>1.具体实现function Super(){<br> // 只在此处声明基本属性和引用属性<br> this.val = 1;<br> this.arr = [1];<br>}<br>//  在此处声明函数<br>Super.prototype.fun1 = function(){};<br>Super.prototype.fun2 = function(){};<br>//Super.prototype.fun3…function Sub(){<br> Super.call(this); // 核心<br> // …<br>}<br>Sub.prototype = new Super(); // 核心</p>
<p>var sub1 = new Sub(1);<br>var sub2 = new Sub(2);<br>alert(sub1.fun === sub2.fun); // true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#10;2.&#26680;&#24515;&#25226;&#23454;&#20363;&#20989;&#25968;&#37117;&#25918;&#22312;&#21407;&#22411;&#23545;&#35937;&#19978;&#65292;&#20197;&#23454;&#29616;&#20989;&#25968;&#22797;&#29992;&#12290;&#21516;&#26102;&#36824;&#35201;&#20445;&#30041;&#20511;&#29992;&#26500;&#36896;&#20989;&#25968;&#26041;&#24335;&#30340;&#20248;&#28857;&#65292;&#36890;&#36807;Super.call(this);&#32487;&#25215;&#29238;&#31867;&#30340;&#22522;&#26412;&#23646;&#24615;&#21644;&#24341;&#29992;&#23646;&#24615;&#24182;&#20445;&#30041;&#33021;&#20256;&#21442;&#30340;&#20248;&#28857;&#65307;&#36890;&#36807;Sub.prototype = new Super();&#32487;&#25215;&#29238;&#31867;&#20989;&#25968;&#65292;&#23454;&#29616;&#20989;&#25968;&#22797;&#29992;&#10;&#10;&#10;3.&#20248;&#32570;&#28857;&#20248;&#28857;&#65306;&#10;&#10;&#9;1. &#19981;&#23384;&#22312;&#24341;&#29992;&#23646;&#24615;&#20849;&#20139;&#38382;&#39064;&#10;&#9;2. &#21487;&#20256;&#21442;&#10;&#9;3. &#20989;&#25968;&#21487;&#22797;&#29992;&#10;&#10;&#32570;&#28857;:&#10;&#10;&#9;1. &#65288;&#19968;&#28857;&#23567;&#29781;&#30133;&#65289;&#23376;&#31867;&#21407;&#22411;&#19978;&#26377;&#19968;&#20221;&#22810;&#20313;&#30340;&#29238;&#31867;&#23454;&#20363;&#23646;&#24615;&#65292;&#22240;&#20026;&#29238;&#31867;&#26500;&#36896;&#20989;&#25968;&#34987;&#35843;&#29992;&#20102;&#20004;&#27425;&#65292;&#29983;&#25104;&#20102;&#20004;&#20221;&#65292;&#32780;&#23376;&#31867;&#23454;&#20363;&#19978;&#30340;&#37027;&#19968;&#20221;&#23631;&#34109;&#20102;&#23376;&#31867;&#21407;&#22411;&#19978;&#30340;&#12290;&#12290;&#12290;&#21448;&#26159;&#20869;&#23384;&#28010;&#36153;&#65292;&#27604;&#21018;&#25165;&#24773;&#20917;&#22909;&#28857;&#65292;&#19981;&#36807;&#30830;&#23454;&#26159;&#29781;&#30133;&#10;&#10;P.S.&#22914;&#26524;&#26080;&#27861;&#29702;&#35299;&#36825;&#20010;&#8221;&#22810;&#20313;&#8220;&#65292;&#21487;&#20197;&#26597;&#30475;&#40687;&#32701;&#36731;&#25196;&#65306;JS&#23398;&#20064;&#31508;&#35760;2_&#38754;&#21521;&#23545;&#35937;&#65292;&#25991;&#31456;&#26411;&#23614;&#26377;&#26356;&#35814;&#32454;&#30340;&#35299;&#37322;&#10;&#23492;&#29983;&#32452;&#21512;&#32487;&#25215;&#65288;&#26368;&#20339;&#26041;&#24335;&#65289;&#20174;&#21517;&#23383;&#23601;&#33021;&#30475;&#20986;&#21448;&#26159;&#23545;&#32452;&#21512;&#32487;&#25215;&#30340;&#20248;&#21270;&#65292;&#19981;&#26159;&#35828;&#32452;&#21512;&#32487;&#25215;&#26377;&#29781;&#30133;&#21527;&#65292;&#27809;&#20851;&#31995;&#65292;&#25105;&#20204;&#25509;&#30528;&#36861;&#27714;&#23436;&#32654;&#10;&#10;&#10;1.&#20855;&#20307;&#23454;&#29616;&#10;```dash&#10;function beget(obj)&#123; // &#29983;&#23401;&#23376;&#20989;&#25968; beget&#65306;&#40857;beget&#40857;&#65292;&#20964;beget&#20964;&#12290;&#10; var F = function()&#123;&#125;;&#10; F.prototype = obj;&#10; return new F();&#10;&#125;&#10;function Super()&#123;&#10; // &#21482;&#22312;&#27492;&#22788;&#22768;&#26126;&#22522;&#26412;&#23646;&#24615;&#21644;&#24341;&#29992;&#23646;&#24615;&#10; this.val = 1;&#10; this.arr = [1];&#10;&#125;&#10;//  &#22312;&#27492;&#22788;&#22768;&#26126;&#20989;&#25968;&#10;Super.prototype.fun1 = function()&#123;&#125;;&#10;Super.prototype.fun2 = function()&#123;&#125;;&#10;//Super.prototype.fun3...function Sub()&#123;&#10; Super.call(this); // &#26680;&#24515;&#10; // ...&#10;&#125;&#10;var proto = beget(Super.prototype); // &#26680;&#24515;&#10;proto.constructor = Sub; // &#26680;&#24515;&#10;Sub.prototype = proto; // &#26680;&#24515;&#10;&#10;var sub = new Sub();&#10;alert(sub.val);&#10;alert(sub.arr);</span><br></pre></td></tr></table></figure></p>
<p>P.S.等等，生孩子函数是啥东西，怎么没听过？还有标明了核心的3句话，怎么没看明白？别着急，我们喝杯茶接着看</p>
<p>2.核心用beget(Super.prototype);切掉了原型对象上多余的那份父类实例属性</p>
<p>3.优缺点优点：完美了<br>缺点：理论上没有了（如果用起来麻烦不算缺点的话。。）<br>P.S.用起来麻烦是一方面，另一方面是因为寄生组合式继承出现的比较晚，是21世纪初的东西，大家等不起这么久，所以组合继承是最常用的，而这个理论上完美的方案却只是课本上的最佳方式了<br>原型式其实介绍完上面的完美方案就可以结束了，但从组合继承到完美方案好像有一段不小的思维跳跃，有必要把故事说清楚</p>
<p>1.具体实现<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function beget(obj)&#123;&#10;// &#29983;&#23401;&#23376;&#20989;&#25968; beget&#65306;&#40857;beget&#40857;&#65292;&#20964;beget&#20964;&#12290;&#10; var F = function()&#123;&#125;;&#10; F.prototype = obj;&#10; return new F();&#10;&#125;&#10;function Super()&#123;&#10; this.val = 1;&#10; this.arr = [1];&#10;&#125;&#10;&#10;// &#25343;&#21040;&#29238;&#31867;&#23545;&#35937;&#10;var sup = new Super();&#10;// &#29983;&#23401;&#23376;&#10;var sub = beget(sup); // &#26680;&#24515;&#10;// &#22686;&#24378;&#10;sub.attr1 = 1;&#10;sub.attr2 = 2;&#10;//sub.attr3...&#10;&#10;alert(sub.val); // 1&#10;alert(sub.arr); // 1&#10;alert(sub.attr1); // 1</span><br></pre></td></tr></table></figure></p>
<p>2.核心用生孩子函数得到得到一个“纯洁”的新对象（“纯洁”是因为没有实例属性），再逐步增强之（填充实例属性）<br>P.S.ES5提供了Object.create()函数，内部就是原型式继承，IE9+支持</p>
<p>3.优缺点优点：</p>
<pre><code>1. 从已有对象衍生新对象，不需要创建自定义类型（更像是对象复制，而不是继承。。）
</code></pre><p>缺点：</p>
<pre><code>1. 原型引用属性会被所有实例共享，因为是用整个父类对象来充当了子类原型对象，所以这个缺陷无可避免
2. 无法实现代码复用（新对象是现取的，属性是现添的，都没用函数封装，怎么复用）
</code></pre><p>寄生式这名字太扯了，而且寄生式是一种模式（套路），并不是只能用来实现继承</p>
<p>1.具体实现function beget(obj){ // 生孩子函数 beget：龙beget龙，凤beget凤。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> var F = function()&#123;&#125;;&#10; F.prototype = obj;&#10; return new F();&#10;&#125;&#10;function Super()&#123;&#10; this.val = 1;&#10; this.arr = [1];&#10;&#125;&#10;function getSubObject(obj)&#123;&#10; // &#21019;&#24314;&#26032;&#23545;&#35937;&#10; var clone = beget(obj); // &#26680;&#24515;&#10; // &#22686;&#24378;&#10; clone.attr1 = 1;&#10; clone.attr2 = 2;&#10; //clone.attr3...&#10;&#10; return clone;&#10;&#125;&#10;&#10;var sub = getSubObject(new Super());&#10;alert(sub.val); // 1&#10;alert(sub.arr); // 1&#10;alert(sub.attr1); // 1</span><br></pre></td></tr></table></figure></p>
<p>2.核心给原型式继承穿了个马甲而已，看起来更像继承了（上面介绍的原型式继承更像是对象复制）<br>注意：beget函数并不是必须的，换言之，创建新对象 -&gt; 增强 -&gt; 返回该对象，这样的过程叫寄生式继承，新对象是如何创建的并不重要（用beget生的，new出来的，字面量现做的。。都可以）</p>
<p>3.优缺点优点：</p>
<pre><code>1. 还是不需要创建自定义类型
</code></pre><p>缺点：</p>
<pre><code>1. 无法实现函数复用（没用到原型，当然不行）
</code></pre><p>P.S.剧情解析：有缺陷的寄生式继承 + 不完美的组合继承 = 完美的寄生组合式继承，不妨回去找找看哪里用到了寄生</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/04/17/类数组/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          类数组
        
      </div>
    </a>
  
  
    <a href="/2016/04/15/跨域/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">跨域解决方法</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>








</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div>&copy; 2016 任先生在路上 的博客 , 技术 
        <a href="http://hexo.io/" target="_blank">Hexo</a>  
      </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>