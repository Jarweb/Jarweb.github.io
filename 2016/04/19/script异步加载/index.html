<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>script异步加载 | Jar-R</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="DOM 渲染流程要理解异步脚本载入的用处首先要了解浏览器渲染DOM的流程，以及各阶段用户体验的差别。 一般地，一个包含外部样式表文件和外部脚本文件的HTML载入和渲染过程是这样的：

浏览器下载HTML文件并开始解析DOM。
遇到样式表文件link[rel=stylesheet]时，将其加入资源文件下载队列，继续解析DOM。
遇到脚本文件时，暂停DOM解析并立即下载脚本文件。
下载结束后立即执行脚">
<meta property="og:type" content="article">
<meta property="og:title" content="script异步加载">
<meta property="og:url" content="http://Jarweb.com/2016/04/19/script异步加载/index.html">
<meta property="og:site_name" content="Jar-R">
<meta property="og:description" content="DOM 渲染流程要理解异步脚本载入的用处首先要了解浏览器渲染DOM的流程，以及各阶段用户体验的差别。 一般地，一个包含外部样式表文件和外部脚本文件的HTML载入和渲染过程是这样的：

浏览器下载HTML文件并开始解析DOM。
遇到样式表文件link[rel=stylesheet]时，将其加入资源文件下载队列，继续解析DOM。
遇到脚本文件时，暂停DOM解析并立即下载脚本文件。
下载结束后立即执行脚">
<meta property="og:updated_time" content="2016-07-13T17:13:15.617Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="script异步加载">
<meta name="twitter:description" content="DOM 渲染流程要理解异步脚本载入的用处首先要了解浏览器渲染DOM的流程，以及各阶段用户体验的差别。 一般地，一个包含外部样式表文件和外部脚本文件的HTML载入和渲染过程是这样的：

浏览器下载HTML文件并开始解析DOM。
遇到样式表文件link[rel=stylesheet]时，将其加入资源文件下载队列，继续解析DOM。
遇到脚本文件时，暂停DOM解析并立即下载脚本文件。
下载结束后立即执行脚">
  
    <link rel="alternative" href="/atom.xml" title="Jar-R" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">任先生在路上</a></h1>
		</hgroup>

		
		<p class="header-subtitle" style="margin-bottom:20px;">Good things are coming !</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger" style="display:none;"></div>
  		<h1 class="header-author js-mobile-header hide">任先生在路上</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">任先生在路上</h1>
			</hgroup>
			
			<p class="header-subtitle">Good things are coming !</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-script异步加载" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/19/script异步加载/" class="article-date">
  	<time datetime="2016-04-18T16:00:00.000Z" itemprop="datePublished">2016-04-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      script异步加载
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js原生/">js原生</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>DOM 渲染流程要理解异步脚本载入的用处首先要了解浏览器渲染DOM的流程，以及各阶段用户体验的差别。 一般地，一个包含外部样式表文件和外部脚本文件的HTML载入和渲染过程是这样的：</p>
<ol>
<li>浏览器下载HTML文件并开始解析DOM。</li>
<li>遇到样式表文件link[rel=stylesheet]时，将其加入资源文件下载队列，继续解析DOM。</li>
<li>遇到脚本文件时，暂停DOM解析并立即下载脚本文件。</li>
<li>下载结束后立即执行脚本，在脚本中可访问当前<script>以上的DOM。</li>
<li>脚本执行结束，继续解析DOM。</li>
<li>整个DOM解析完成，触发DOMContentLoaded事件。</li>
</ol>
<p>上述步骤只是大致的描述，你可能还会关心下面两个问题：</p>
<ul>
<li>资源文件下载队列。样式表、图片等资源文件的下载不会暂停DOM解析。浏览器会并行地下载这些文件，但通常会限制并发下载数，一般为3-5个。可以在开发者工具的Network标签页中看到。</li>
<li>执行脚本文件前，浏览器可能会等待该<script>之前的样式下载完成并渲染结束。</li>
</ul>
<a id="more"></a>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;!DOCTYPE html&#62;&#10;&#60;html&#62;&#10;&#60;body&#62;&#10;  &#60;h1&#62;Hello&#60;/h1&#62;&#10;  &#60;script src=&#34;/will-not-stop-loading.js&#34;&#62;&#60;/script&#62;&#10;  &#60;h1&#62;World!&#60;/h1&#62;&#10;&#60;/body&#62;&#10;&#60;/html&#62;</span><br></pre></td></tr></table></figure>
<p>脚本等待下载完成的过程中，后面的World不会显示出来。直到该脚本载入完成或超时。 试想如果你在<head>中有这样一个下载缓慢的脚本，整个<body>都不会显示， 势必会造成空白页面持续相当长的时间。 所以较好的实践方式是将脚本放在<body>尾部。</p>
<p>既然脚本载入会暂停DOM渲染，OK我们把脚本都放在<body>尾部。 这时页面可以被显示出来了，但是在脚本载入前，DOMContentLoaded事件仍然不会触发。 请看：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;!DOCTYPE html&#62;&#10;&#60;html&#62;&#10;&#60;body&#62;&#10;  &#60;h1&#62;Hello&#60;/h1&#62;&#10;  &#60;h1&#62;World!&#60;/h1&#62;&#10;  &#60;script&#62;&#10;    document.addEventListener(&#39;DOMContentLoaded&#39;, function()&#123;&#10;      alert(&#39;DOM loaded!&#39;);&#10;    &#125;);&#10;  &#60;/script&#62;&#10;  &#60;script src=&#34;/will-not-stop-loading.js&#34;&#62;&#60;/script&#62;&#10;&#60;/body&#62;&#10;&#60;/html&#62;</span><br></pre></td></tr></table></figure>
<p>这时Wrold!会显示，但浏览器忙指示器仍在旋转。 这是因为 DOM 仍然没有解析完成，毕竟最后一个<script>标签还未获取到嘛！ 当然DOMContentLoaded事件也就不会触发。DOM loaded!对话框也不会弹出来。</p>
<p>对于非必须的页面脚本，在它的载入过程中如何取消浏览器的忙提示。<br>首先想到的办法一定是从HTML中干掉那些<script>，然后在JavaScript中动态插入<script>标签。比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var s = document.createElement(&#39;script&#39;);&#10;s.src = &#34;/will-not-stop-loading.js&#34;;&#10;document.body.appendChild(s);</span><br></pre></td></tr></table></figure>
<p>那么等DOMContentLoaded会后再来插入呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#39;DOMContentLoaded&#39;, function()&#123;&#10;    var s = document.createElement(&#39;script&#39;);&#10;    s.src = &#34;/will-not-stop-loading.js&#34;;&#10;    document.body.appendChild(s);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码仍然无法阻止浏览器忙提示。这充分说明浏览器JavaScript执行是单线程的，DOM事件机制也不例外。</p>
<p>在实际的项目中有两种成熟的办法可以禁止浏览器忙提示。<br>AJAX + Eval使用AJAX获取脚本内容，并用Eval来运行它。 因为AJAX一般不会触发浏览器忙提示，脚本执行只可能让浏览器暂停响应也不会触发忙提示。<br>首先在需要异步加载的脚本设置type=”text/defered-script”，并用data-src代替src防止浏览器直接去获取：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;script type=&#34;text/async-script&#34; data-src=&#34;http://foo.com/bar.js&#34;&#62;</span><br></pre></td></tr></table></figure>
<p>然后在站点的公共代码中加入『异步脚本加载器』：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&#39;[type=&#34;text/defered-script&#34;]&#39;).each(function(idx, el)&#123;&#10;    $.get(el.dataset.src, eval);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Load 事件<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(window).load(function()&#123;&#10;  $(&#39;script[type=&#34;text/async-script&#34;]&#39;).each(function(idx, el)&#123;&#10;    var $script = $(&#39;&#60;script&#62;&#39;);&#10;    if(el.dataset.src) $script.attr(&#39;src&#39;, el.dataset.src);&#10;    else $script.html(el.text);&#10;    $script.appendTo(&#39;body&#39;); el.remove(); &#125;);&#10;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>更通用的动态加载方式基于我的理解和上一节的引用中的内容，可以认为绝大部分浏览器动态加载脚本的方式如下：</p>
<ol>
<li>动态加载多个脚本时，这些脚本的加载（IO操作）可能并行，可能串行。</li>
<li>一个脚本一旦加载完毕（IO结束），该脚本放入“待执行队列”，等待出队供js引擎去执行。</li>
</ol>
<p>其中，“加载完毕”这是一个事件，浏览器的支持监测这个事件。这个事件在IE下是onreadystatechange，其他浏览器下是onload。据此，Loading JavaScript without blocking给出了下面的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function loadScript(url, callback)&#123; var script = document.createElement(&#34;script&#34;)&#10;    script.type = &#34;text/javascript&#34;; if (script.readyState)&#123; //IE&#10;      script.onreadystatechange = function()&#123;&#10;        if (script.readyState == &#34;loaded&#34; ||script.readyState == &#34;complete&#34;)&#123;&#10;          script.onreadystatechange = null;&#10;          callback();&#10;        &#125;&#10;      &#125;;&#10;    &#125; else &#123; //Others&#10;      script.onload = function()&#123;&#10;            callback();&#10;        &#125;;&#10;    &#125;&#10;&#10;    script.src = url; document.body.appendChild(script);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>callback函数可以是去加载另外一个js，不过如果要加载的js文件较多，就成了“回调地狱”。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Loader = (function() &#123;&#10;  var load_cursor = 0;&#10;  var load_queue;&#10;  var load_finished = function() &#123;&#10;    load_cursor ++;&#10;    if (load_cursor &#60; load_queue.length) &#123; loadScript(); &#125; &#125;&#10;    var loadScript = function() &#123;&#10;      var url = load_queue[load_cursor];&#10;      var script = document.createElement(&#39;script&#39;);&#10;      script.type = &#34;text/javascript&#34;;&#10;      if (script.readyState)&#123; //IE&#10;        script.onreadystatechange = function()&#123;&#10;      if (script.readyState == &#34;loaded&#34; || script.readyState == &#34;complete&#34;)&#123;&#10;        script.onreadystatechange = null; load_finished(); &#125; &#125;; &#125;&#10;       else &#123; //Others&#10;          script.onload = function()&#123; load_finished(); &#125;;&#10;        &#125;&#10;  script.src = url+&#39;?&#39;+&#39;time=&#39;+Date.parse(new Date());&#10;  document.body.appendChild(script);&#10;&#125;;&#10;  var loadMultiScript = function(urlArray) &#123;&#10;    load_queue = urlArray;&#10;    for (var idx=0; idx &#60; urlArray.length; idx++) &#123;&#10;      loadScript(urlArray[idx]);&#10;    &#125; &#125;&#10;    return &#123;&#10;      load: loadMultiScript,&#10;  &#125;;&#10; &#125;)(); // end Loader // load...&#10; Loader.load([&#39;http://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.0/jquery.min.js&#39;, &#39;./my.js&#39;]);</span><br></pre></td></tr></table></figure>
</script></li></ol>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/04/21/css动画库/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          css动画库
        
      </div>
    </a>
  
  
    <a href="/2016/04/18/StackBlur高斯模糊的效果库/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">StackBlur高斯模糊的效果库</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>








</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div>&copy; 2016 任先生在路上 的博客 , 技术 
        <a href="http://hexo.io/" target="_blank">Hexo</a>  
      </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>