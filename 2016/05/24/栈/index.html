<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>栈 | Jar-R</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="栈。栈是一种遵从后进先出原则(LIFO,全称为Last In First Out)的有序集合。栈顶永远是最新的元素。举个例子就是:栈就像放在箱子里的一叠书 你要拿下面的书先要把上面的书拿开。(当然，你不能先拿下面的书。)看图示也可明白。
JavaScipt中栈的实现首先，创建一个构造函数。
/**

栈的构造函数*/function Stack() { // 用数组来模拟栈 var item =">
<meta property="og:type" content="article">
<meta property="og:title" content="栈">
<meta property="og:url" content="http://Jarweb.com/2016/05/24/栈/index.html">
<meta property="og:site_name" content="Jar-R">
<meta property="og:description" content="栈。栈是一种遵从后进先出原则(LIFO,全称为Last In First Out)的有序集合。栈顶永远是最新的元素。举个例子就是:栈就像放在箱子里的一叠书 你要拿下面的书先要把上面的书拿开。(当然，你不能先拿下面的书。)看图示也可明白。
JavaScipt中栈的实现首先，创建一个构造函数。
/**

栈的构造函数*/function Stack() { // 用数组来模拟栈 var item =">
<meta property="og:updated_time" content="2016-05-23T17:29:40.447Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="栈">
<meta name="twitter:description" content="栈。栈是一种遵从后进先出原则(LIFO,全称为Last In First Out)的有序集合。栈顶永远是最新的元素。举个例子就是:栈就像放在箱子里的一叠书 你要拿下面的书先要把上面的书拿开。(当然，你不能先拿下面的书。)看图示也可明白。
JavaScipt中栈的实现首先，创建一个构造函数。
/**

栈的构造函数*/function Stack() { // 用数组来模拟栈 var item =">
  
    <link rel="alternative" href="/atom.xml" title="Jar-R" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">任先生在路上</a></h1>
		</hgroup>

		
		<p class="header-subtitle" style="margin-bottom:20px;">Good things are coming !</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger" style="display:none;"></div>
  		<h1 class="header-author js-mobile-header hide">任先生在路上</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://img.ycwb.com/news/attachement/jpg/site2/20120717/001e90704bd5116f25f84a.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">任先生在路上</h1>
			</hgroup>
			
			<p class="header-subtitle">Good things are coming !</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Jarweb" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-栈" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/24/栈/" class="article-date">
  	<time datetime="2016-05-23T17:29:40.447Z" itemprop="datePublished">2016-05-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      栈
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js原生/">js原生</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>栈。<br>栈是一种遵从后进先出原则(LIFO,全称为Last In First Out)的有序集合。栈顶永远是最新的元素。<br>举个例子就是:栈就像放在箱子里的一叠书 你要拿下面的书先要把上面的书拿开。(当然，你不能先拿下面的书。)<br>看图示也可明白。</p>
<p>JavaScipt中栈的实现首先，创建一个构造函数。</p>
<p>/**</p>
<ul>
<li>栈的构造函数<br>*/<br>function Stack() { // 用数组来模拟栈 var item = [];<br>}</li>
</ul>
<p>栈需要有如下的方法:</p>
<ul>
<li>push(element(s)): 添加几个元素到栈顶</li>
<li>pop(): 移除并返回栈顶元素</li>
<li>peek(): 返回栈顶元素</li>
<li>isAmpty: 检查栈是否为空，为空则返回true</li>
<li>clear: 移除栈中所有元素</li>
<li>size: 返回栈中元素个数。</li>
<li>print: 以字符串显示栈中所有内容</li>
</ul>
<a id="more"></a>
<p>push方法的实现说明: 需要往栈中添加新元素，元素位置在队列的末尾。也就是说，我们可以用数组的push方法来模拟实现。<br>实现:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#23558;&#20803;&#32032;&#36865;&#20837;&#26632;&#65292;&#25918;&#32622;&#20110;&#25968;&#32452;&#30340;&#26368;&#21518;&#19968;&#20301;&#10; * @param  &#123;Any&#125; element &#25509;&#21463;&#30340;&#20803;&#32032;&#65292;&#19981;&#38480;&#21046;&#31867;&#22411;&#10; */ &#10;&#10; this.push = function(element) &#123;&#10;  items.push(element);&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>pop方法的实现说明: 需要把栈顶元素弹出，同时返回被弹出的值。可以用数组的pop方法来模拟实现。<br>实现:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#24377;&#20986;&#26632;&#39030;&#20803;&#32032;&#10; * @return &#123;Any&#125; &#36820;&#22238;&#34987;&#24377;&#20986;&#30340;&#20540;&#10; */ &#10;&#10; this.pop = function() &#123; return items.pop();&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>peek方法的实现说明: 查看栈顶元素，可以用数组长度来实现。<br>实现:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#26597;&#30475;&#26632;&#39030;&#20803;&#32032;&#10; * @return &#123;Any&#125; &#36820;&#22238;&#26632;&#39030;&#20803;&#32032;&#10; */ &#10; this.peek = function() &#123; return items[items.length - 1];&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>其余方法的实现说明: 前三个是栈方法的核心，其余方法则在此一次性列出。因为下文要讲的队列，会与这部分有很大重合。<br>实现:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#30830;&#23450;&#26632;&#26159;&#21542;&#20026;&#31354;&#10; * @return &#123;Boolean&#125; &#33509;&#26632;&#20026;&#31354;&#21017;&#36820;&#22238;true,&#19981;&#20026;&#31354;&#21017;&#36820;&#22238;false&#10; */ &#10;&#10; this.isAmpty = function() &#123; return items.length === 0 &#125;; &#10;&#10; /**&#10; * &#28165;&#31354;&#26632;&#20013;&#25152;&#26377;&#20869;&#23481;&#10; */ &#10;&#10; this.clear = function() &#123;&#10;  items = [];&#10;&#125;;&#10;&#10; /**&#10; * &#36820;&#22238;&#26632;&#30340;&#38271;&#24230;&#10; * @return &#123;Number&#125; &#26632;&#30340;&#38271;&#24230;&#10; */ &#10;&#10; this.size = function() &#123; return items.length;&#10;&#125;; &#10;&#10;/**&#10; * &#20197;&#23383;&#31526;&#20018;&#26174;&#31034;&#26632;&#20013;&#25152;&#26377;&#20869;&#23481;&#10; */ &#10;&#10; this.print = function() &#123; console.log(items.toString());&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>实际应用栈的实际应用比较多，书中有个十进制转二进制的函数。(不懂二进制怎么算的话可以百度)下面是函数的源代码。<br>原理就是输入要转换的数字，不断的除以二并取整。并且最后运用while循环，将栈中所有数字拼接成字符串输出。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#23558;10&#36827;&#21046;&#25968;&#23383;&#36716;&#20026;2&#36827;&#21046;&#25968;&#23383;&#10; * @param  &#123;Number&#125; decNumber &#35201;&#36716;&#25442;&#30340;10&#36827;&#21046;&#25968;&#23383;&#10; * @return &#123;Number&#125;           &#36716;&#25442;&#21518;&#30340;2&#36827;&#21046;&#25968;&#23383;&#10; */ &#10;&#10; function divideBy2(decNumber) &#123; var remStack = new Stack(),&#10;    rem,&#10;    binaryString = &#39;&#39;; while (decNumber &#62; 0) &#123;&#10;    rem = Math.floor(decNumber % 2);&#10;    remStack.push(rem);&#10;    decNumber = Math.floor(decNumber / 2);&#10;  &#125; while (!remStack.isAmpty()) &#123;&#10;    binaryString += remStack.pop().toString();&#10;  &#125; return binaryString;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>到此而言，栈的学习就告一段落了。因为源代码中注释较多，所以这儿就不贴出源代码的内容了。有兴趣的可以自己下载查看。<br>源代码<br>队列队列与栈是很相像的数据结构，不同之处在于队列是是先进先出(FIFO:First In First Out)的。<br>举个例子: 火车站排队买票，先到的先买。(插队的不算)，是不是很好理解了~<br>JavaScipt中队列的实现队列的实现和栈很像。首先依然是构造函数:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#38431;&#21015;&#26500;&#36896;&#20989;&#25968;&#10; */ &#10;&#10; function Queue() &#123; var items = [];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>队列需要有如下的方法:</p>
<ul>
<li>enqueue(element(s)): 向队列尾部添加几个项</li>
<li>dequeue(): 移除队列的第一项(也就是排在最前面的项)</li>
<li>front(): 返回队列的第一个元素，也就是最新添加的那个</li>
</ul>
<p>其余方法与队列相同<br>enqueue方法的实现说明: 向队列尾部添加几个项。<br>实现:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#23558;&#20803;&#32032;&#25512;&#20837;&#38431;&#21015;&#23614;&#37096;&#10; * @param  &#123;Any&#125; ele &#35201;&#25512;&#20837;&#38431;&#21015;&#30340;&#20803;&#32032;&#10; */ &#10;&#10; this.enqueue = function(ele) &#123;&#10;  items.push(ele);&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>dequeue方法的实现说明: 移除队列的第一项。<br>实现:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#23558;&#38431;&#21015;&#20013;&#31532;&#19968;&#20010;&#20803;&#32032;&#24377;&#20986;&#10; * @return &#123;Any&#125; &#36820;&#22238;&#34987;&#24377;&#20986;&#30340;&#20803;&#32032;&#10; */ &#10;&#10; this.dequeue = function() &#123; return items.shift()&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>front方法的实现说明: 返回队列的第一个元素，也就是最新添加的那个。<br>实现:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#26597;&#30475;&#38431;&#21015;&#30340;&#31532;&#19968;&#20010;&#20803;&#32032;&#10; * @return &#123;Any&#125; &#36820;&#22238;&#38431;&#21015;&#20013;&#31532;&#19968;&#20010;&#20803;&#32032;&#10; */ &#10;&#10; this.front = function() &#123; return items[0];&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>以上的三个方法，就是队列这种数据结构的核心方法了。其实很好理解的。<br>实际应用书上的是个击鼓传花的小游戏。原理就是循环到相应位置时，队列弹出那个元素。最后留下的就是赢家。<br>源代码如下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#20987;&#40723;&#20256;&#33457;&#30340;&#23567;&#28216;&#25103;&#10; * @param &#123;Array&#125;  nameList &#21442;&#19982;&#20154;&#21592;&#21015;&#34920;&#10; * @param &#123;Number&#125; num      &#22312;&#24490;&#29615;&#20013;&#35201;&#34987;&#24377;&#20986;&#30340;&#20301;&#32622;&#10; * @return &#123;String&#125;          &#36820;&#22238;&#36194;&#23478;(&#20063;&#23601;&#26159;&#26368;&#21518;&#27963;&#19979;&#26469;&#30340;&#37027;&#20010;)&#10; */ &#10;&#10; function hotPotato(nameList, num) &#123; var queue = new Queue(); for (var i = 0; i &#60; nameList.length; i++) &#123;&#10;    queue.enqueue(nameList[i]);&#10;  &#125; var eliminated = &#39;&#39;; while (queue.size() &#62; 1) &#123; for (var i = 0; i &#60; num; i++) &#123;&#10;      queue.enqueue(queue.dequeue());&#10;    &#125;&#10;&#10;    eliminated = queue.dequeue();&#10;    console.log(eliminated + &#34; Get out!&#34;)&#10;  &#125; return queue.dequeue()&#10;&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/05/24/再看this/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          再看this
        
      </div>
    </a>
  
  
    <a href="/2016/05/24/捕获冒泡/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">捕获与冒泡</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>








</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div>&copy; 2016 任先生在路上 的博客 , 技术 
        <a href="http://hexo.io/" target="_blank">Hexo</a>  
      </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>